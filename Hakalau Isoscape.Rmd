---
title: "Hakalau Isoscape"
author: "CB Wall"
date: "9/11/2019"
output:
  html_document:
    code_folding: hide
    toc: yes
    toc_depth: 4
    toc_float: yes
  pdf_document:
    toc: yes
    toc_depth: '4'
editor_options: 
  chunk_output_type: console
---

```{r global options, results="hide", warning=FALSE, message=FALSE}
if (!require('knitr')) install.packages('knitr'); library('knitr')
knitr::opts_chunk$set(warning=FALSE, message=FALSE, fig.align='center')

# Load in packages
if (!require("pacman")) install.packages("pacman"); library(pacman) # for rapid install if not in library

# load packages
pacman::p_load("RgoogleMaps", "SDMTools", "rgdal", "ggmap", "gridExtra", "automap", "cowplot","sp", "gstat", "plotrix", "dplyr", "ggplot2", "scales","magrittr","plyr","effects", "ggpubr", "sjstats", "RColorBrewer")

```

## Background  
**Hakalau National Forest Wildlife Refuge Isoscapes**  
Data collected 20-21 August 2019 in Hakalau Forest, Hawai'i Island. Soil and plant samples collected from  afforested/planted pots after a century of deforestation from cattle grazing (*AK sites*) and remnant koa forests (*RK sites*). Target engineers of forest habitats are *Acacia koa* (common Hawaiian name: *Koa*), an indigenous hardwood species that forms native forest canopies and associates with nitrogen fixing bacteria. Understory species include *Rubus argutus* -- an invasive species (common name: sawtooth blackberry) -- and an endemic species *Rubus hawaiiensis* (common name: 'Ākala); both are members of the Roseaceae family. Noteably, *R. argutus* was found more in the remnant plot (i.e., RK) and the indigenous *R. hawaiiensis* was common in the restored plot (i.e, AK). 

Soil samples were collected in a spatially explicit fashion (every 4 or 5m) with a 20 x 35m superplot, consisting of thirty-five 4 x 5m subplots. This data was used to create a δ^13^C and δ^15^N stable isotope landscape, hereafter 'isoscape'. Koa and *Rubus* spp. were collected within each 4 x 5m sublot.  

*Plot densities were...*  
AK: Koa (18 trees) Rubus (14 plants) per 20 x 35m plot= *0.026 Koa m^-2^, 0.020 Rubus m^-2^*
RK: Koa (10 trees) Rubus (28 plants) per 20 x 35m plot= *0.014 Koa m^-2^, 0.040 Rubus m^-2^*

### Site Maps
```{r, site maps, fig.cap="Figure 1. Site map of (a) the Hawaiian Island archipelago, (b) sampling plot in Hakalau Forest Refuge, and (c) plot layouts, highlighting *Acacia koa* density.", fig.align='center'}

# load data
Hak.gps<-read.csv("data/Hakalau.gps.csv")
API<-read.csv("data/API_key.csv")
API.key<-API[1,1]

ggplot(Hak.gps, aes(x = longitude, y = latitude)) +
  coord_quickmap() +
  geom_point()

######## using ggmap
register_google(key=API.key)

########
#Hawaiian islands Map
########
hi_map<-get_map(location=c(-157,20.5),zoom=7,maptype="satellite",color="color")
hi_map_for_man <- ggmap(hi_map) +
  geom_point(aes(x = -155.320, y = 19.83), pch=23,colour="black",fill="red", size = 2, stroke=0.5) +
  xlab("") + ylab("Latitude") +
  scale_y_continuous(limits=c(18.8, 22.2))+
  scale_x_continuous(limits=c(-160.2, -154)) +
  theme(axis.text=element_text(colour="black",size=5),
        axis.title=element_text(colour="black",size=8),
        plot.margin = unit(c(0, 0.5, 0, 0.7), "cm")) +
  ggsn::scalebar(x.min=-160.2, x.max=-154, y.min=18.8, y.max=22.2, dist=50, dist_unit="km", transform=TRUE,
                 st.bottom=FALSE, st.size=2, box.fill=c("gray50", "white"), model="WGS84",st.color="white", border.size=0.5)


##########
# site map plot showing distance from plots
##########
Hak.rev=c(-155.317, 19.82158002)

map2<-get_map(Hak.rev, 
                      zoom=16, 
                      scale = 2, 
                      maptype= "satellite",
                      source="google", extent= "device", legend="topright")

## site single point only
site.only<-Hak.gps[c(1,5),]
Hakalau.site<-
  ggmap(map2)+
  geom_point(aes(x=longitude, y=latitude), data=site.only, alpha=0.5, color="white", size=4)+
  labs(x="", y="") +
  scale_y_continuous(limits=c(19.81785, 19.8242))+
  scale_x_continuous(limits=c(-155.3223, -155.311)) +
  theme(text = element_text(size=6),
       plot.margin = unit(c(0.2, 0.5, 0.2, 0.2), "cm")) +
  annotate("text", x=-155.3187, y=19.8225, label= "AK", size=3, col="white") +
  annotate("text", x=-155.31478, y=19.8224, label= "RK", size=3, col="white") +
ggsn::scalebar(x.min=-155.314, x.max=-155.311, y.min=19.818, y.max=19.824, dist=100, 
               dist_unit="m", transform=TRUE,
              st.bottom=FALSE, st.size=2, box.fill=c("gray50", "white"), model="WGS84",st.color="white", border.size=0.5)
Hakalau.site


##########
# Site plots: AK or RK only
##########
AK<- Hak.gps[(Hak.gps$Site=="AK"),]
RK<- Hak.gps[(Hak.gps$Site=="RK"),]

####### AK map
AK.gps<-c(-155.3189, lat=19.8219)
mapAK<-get_map(AK.gps,
              zoom=19, 
              scale = 2, 
              maptype= "satellite",
              source="google", extent= "device", legend="topright")

AK.map<-ggmap(mapAK, group=type)+
  geom_point(aes(x=longitude, y=latitude, shape=type, color=type), data=AK, alpha=0.5, size=3)+
  scale_y_continuous(limits=c(19.82165, 19.82225))+
  scale_x_continuous(limits=c(-155.3194, -155.3183)) +
  theme(legend.position="top",
    legend.text = element_text(color = "white"),
    legend.title = element_text(color = "white"),
    legend.key = element_rect(fill = "white"),
    plot.margin = unit(c(0, 0.5, 0, 0), "cm"),
    text = element_text(size=8)) +
  guides(colour= guide_legend(override.aes = list(color = "white"))) +
  scale_color_manual(values=c('red','mediumseagreen'))+
  labs(x="Longitude", y="Latitude") +
  annotate("text", x=-155.31925, y=19.82225, label= "Afforested (AK)", size=3, col="white")+
  ggsn::scalebar(x.min=-155.3183, x.max=-155.3187, y.min=19.82165, y.max=19.82225, dist=10, 
               dist_unit="m", transform=TRUE,
              st.bottom=FALSE, st.size=2, box.fill=c("gray50", "white"), model="WGS84", st.color="white", border.size=0.5)


####### RK map
RK.edit<-RK[-12,] # remove "proximate" Koa
RK.edit[9,3]<-"koa" # rename to be "koa"

RK.gps<-c(-155.315, 19.8216)
mapRK<-get_map(RK.gps,
               zoom=19, 
               scale = 2, 
               maptype= "satellite",
               source="google", extent= "device", legend="topright")

RK.map<-ggmap(mapRK, group=type)+
  geom_point(aes(x=longitude, y=latitude, shape=type, color=type), data=RK.edit, alpha=0.5, size=3)+
  scale_color_manual(values=c('red','mediumseagreen', "dodgerblue"))+
  scale_shape_manual(values=c(16, 17, 3)) +
  scale_y_continuous(limits=c(19.82120, 19.82195))+
  scale_x_continuous(limits=c(-155.31575, -155.3144)) +
  theme(legend.position="top",
        legend.title=element_blank(), 
        legend.key = element_rect(fill = "white"),
        plot.margin = unit(c(0, 0.5, 0, 0), "cm"), 
        text = element_text(size=8)) +
  labs(x="Longitude", y="") +
  annotate("text", x=-155.3156, y=19.82193, label= "Remnant (RK)", size=3, col="white")+
  ggsn::scalebar(x.min=-155.3148, x.max=-155.3144, y.min=19.8212, y.max=19.8219, dist=10, 
               dist_unit="m", transform=TRUE,
              st.bottom=FALSE, st.size=2, box.fill=c("gray50", "white"), model="WGS84", st.color="white", border.size=0.5)


site.plots<-plot_grid(hi_map_for_man, Hakalau.site, AK.map, RK.map, 
          labels=c('a', 'b', 'c', 'd'), label_size=8, hjust=-1, vjust= 2, ncol=2, nrow=2)

### export it
pdf(file= "figures/Fig1.sitemaps.pdf", height=7, width=8)
site.plots
dev.off()

```

#### Ecology and Isotopes data  
- DBH calculations  
- data mutating  
- test scatters of all samples by habitat  
```{r, Hak data, fig.show=FALSE}
Hak.df<-read.csv("data/Hakalau.isotopes.csv")

########## DBH 
DBH.df<- Hak.df %>%
  select(c(DBH..cm.1, DBH..cm.2, DBH..cm.3, DBH..cm.4, DBH..cm.5))

# replace NAs with zeros
DBH.df<- DBH.df %>%
  mutate_each(funs(replace(., which(is.na(.)), 0)))

# if only one trunk, then make new column and report this value
DBH.df <- DBH.df %>%
  mutate(DBH.1trunk = ifelse(DBH..cm.2>"0", 0, DBH..cm.1))

# if multiple trunks, sum of squares and square root all trunks
# and plug in the DBH for single trunks
DBH.df <- DBH.df %>%
  mutate(DBH.Total = ifelse(DBH.1trunk=="0",  
                     sqrt(DBH..cm.1^2 + DBH..cm.2^2 + DBH..cm.3^2 + DBH..cm.4^2 + DBH..cm.5^2), DBH.1trunk))

# replace zeros with NA now that total DBH has been calculated
DBH.df$DBH.Total<-as.numeric(ifelse(DBH.df$DBH.Total=="0", "NA", DBH.df$DBH.Total))

############ Canopy diameter
# use area of an elipse, a x b x π, where a and b are major and minor radius
Can.df<-Hak.df %>%
  select(c(canopy.0..m, canopy.90..m, canopy.180..m, canopy.270..m))

# Major radius is the average of 0 and 180 degrees
Can.df<- Can.df %>% 
  mutate(Maj.rad = rowMeans(cbind(canopy.0..m, canopy.180..m), na.rm=T))

# Minor radius is the average of 90 and 270 degrees
Can.df<- Can.df %>% 
  mutate(Min.rad = rowMeans(cbind(canopy.90..m, canopy.270..m), na.rm=T))

# Elipse area
Can.df<- Can.df %>% 
  mutate(Canopy.area = ifelse(Maj.rad>0, Maj.rad*Min.rad*3.14, "NA"))

########################
# combine DBH.Total and Canopy.area with isotope dataframe and reduce columns
Hak.df$DBH.Total<-DBH.df$DBH.Total
Hak.df$Canopy.area<-Can.df$Canopy.area

# Hak.data is the full dataframe
Hak.data<- Hak.df %>%
  select(c(Plot, Position.point, Sample, DBH.Total, Canopy.area, d15N, d13C, N..percent, Total.N..mmol.gdw, C..percent, Total.C..mmol.gdw, C.N))

########################
########################
########################

# test plots

### Scatter of d13C vs. d15N
iso.scatter<-ggplot(data=Hak.data, aes(x=d13C, y=d15N, color=Plot, shape=Sample))+
  geom_point(cex=1.5) +
  xlab(expression(paste(delta^{13}, C, " (\u2030, V-PDB)"))) +
  ylab(expression(paste(delta^{15}, N, " (\u2030, air)"))) 

### Scatter of total C vs. total N
total.nut<-ggplot(data=Hak.data, aes(x=Total.C..mmol.gdw, y=Total.N..mmol.gdw, color=Plot, shape=Sample))+
  geom_point(cex=1.5) +
  xlab("total Carbon") +
  ylab("total Nitrogen")

#  figures together
plot_grid(iso.scatter, total.nut,
     labels=c('a', 'b'), label_size=10, hjust=-1, vjust= 3, ncol=2, nrow=1)
dev.copy(pdf, "figures/scatter.data.pdf", width=7, height=4, encod="MacRoman")
dev.off()
```
  
#### Rubus and Koa relationship  
- plotting the relationship between Rubus and Koa d15N  
- took average of 3 closest Koa trees to each Rubus plant  
- plot Rubus d15N against Koa d15N (mean of 3 trees)  

```{r rubus and koa, fig.cap="Figure 2a. Relationship between d15N-Koa and 15N-Rubus at two sampling sites.", fig.align='center'}
Ndfa<-read.csv("data/Ndfa.Rub.csv")

# rename the d15N so we know it is for rubus
Ndfa$d15N.Rub<-Ndfa$d15N
Ndfa$d15N.Koa<-Ndfa$mean.d15N.Ndfa

####################
#################### relationship between koa and rubus d15N?
# Yes, but a bit stronger in the RK site
mod.AK<-lm(Ndfa[(Ndfa$Plot=="AK"),]$d15N.Rub~Ndfa[(Ndfa$Plot=="AK"),]$d15N.Koa); anova(mod.AK)
int.rubAK<-coef(summary(mod.AK))[1] #intercept
slop.rubAK<-coef(summary(mod.AK))[2] #slope
                                  
mod.RK<-lm(Ndfa[(Ndfa$Plot=="RK"),]$d15N.Rub~Ndfa[(Ndfa$Plot=="RK"),]$d15N.Koa); anova(mod.RK)
int.RKoa<-coef(summary(mod.RK))[1] #intercept
slop.RKoa<-coef(summary(mod.RK))[2] #slope

#### plot
BW.back<-theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black", size=0.2))

Rub.Koa.d15N.plot<-ggplot(data=Ndfa, aes(x=d15N.Koa, y=d15N.Rub, color=Plot))+
  geom_point(aes(color=Plot), alpha=.8) + 
  scale_color_manual(values=c("coral", "dodgerblue")) +
  coord_equal() + theme_bw() +
  xlab(expression(paste(italic("Acacia koa "), delta^{15}, N, " (\u2030)"), sep=""))+
  ylab(expression(paste(italic("Rubus"), " spp. ", delta^{15}, N, " (\u2030)"), sep="")) +
  guides(colour=guide_legend(override.aes = list(stroke=1, fill=NA, alpha=1))) +
  geom_smooth(method = "lm", alpha = .1, aes(fill = Plot), size=0.6) +
  theme(legend.title = element_blank(),
        axis.text=element_text(size=6),
        axis.title=element_text(size=10))+
  annotate(geom="text", x=2.7, y=0.8, label=expression(paste("AK ", italic("p"), "=0.056")), size=2) +
  annotate(geom="text", x=2.7, y=0.6, label=expression(paste("RK ", italic("p="), bold("0.006"))), size=2) +
  BW.back

Rub.Koa.d15N.plot
dev.copy(pdf, "figures/Rub.Koa.d15N.plot.pdf", width=4, height=4, encod="MacRoman")
dev.off()
```
  
  
#### Degree of nitrogen fixation (Ndfa %)  
- the degree of nitrogen fixation takes into account the target nitrogen fixer (Koa) and a non-fixing reference plant (Rubus spp.) and Beta. Beta is the value when all nitrgen % in fixing plant comes from nitrogen fixation and is estimated, usually as -2 to 0. The formula is:  
$Ndfa (\%) = (δ^{15}N~ref~ - δ^{15}N~fixer~) / (δ^{15}N~ref~ - Beta)* 100$   

Here we use Rubus spp. maximum and median d15N values (pooled across sites) are used as reference plants and a Beta of -1 and -2 to see the % Ndfa of Koa across its range of d15N values.   

```{r Beta Ndfa, fig.cap="Figure 2b-c. The degree of fixed nitrogen from the atmospheric (Ndfa) contributing to Acacia koa percent nitrogen using two assumptions for Beta (δ15N value where Ndfa=100%)", fig.align='center'}
# Beta and Ndfa
# ability for Koa to fix

################# Need new dataframe of KOA and Rubus 
########### separate data frame
# full Hak data dataframe
Ndfa.Hak<- Hak.data %>%
  select(c(Plot, Sample, d15N))

Ndfa.AK<-Ndfa.Hak[(Ndfa.Hak$Plot=="AK"),]
Ndfa.RK<-Ndfa.Hak[(Ndfa.Hak$Plot=="RK"),]

# AK Rubs
AK.R.min<-min(Ndfa.AK[(Ndfa.AK$Sample=="RUBHAW"),]$d15N) # 0.6
AK.R.max<-max(Ndfa.AK[(Ndfa.AK$Sample=="RUBHAW"),]$d15N) # 3.15
AK.R.med<-median(Ndfa.AK[(Ndfa.AK$Sample=="RUBHAW"),]$d15N) # 1.94
AK.R.av<-mean(Ndfa.AK[(Ndfa.AK$Sample=="RUBHAW"),]$d15N) # 1.9

# RK Rubs
RK.R.min<-min(Ndfa.RK[(Ndfa.RK$Sample=="RUBARG"),]$d15N) # 0.99
RK.R.max<-max(Ndfa.RK[(Ndfa.RK$Sample=="RUBARG"),]$d15N) # 4.53
RK.R.med<-median(Ndfa.RK[(Ndfa.RK$Sample=="RUBARG"),]$d15N) # 3.03
RK.R.av<-mean(Ndfa.RK[(Ndfa.RK$Sample=="RUBARG"),]$d15N) # 2.93

############## TO USE
# all mean, all min, all max
All.Rub<-Ndfa.Hak[(Ndfa.Hak$Sample=="RUBHAW" | Ndfa.Hak$Sample=="RUBARG"),]
Rub.av<-mean(All.Rub$d15N) # 2.59
Rub.med<-median(All.Rub$d15N) # 2.59
Rub.min<-min(All.Rub$d15N) # 0.6
Rub.max<-max(All.Rub$d15N) # 4.53

# AK and RK Koa dataframes
All.Koa<- Ndfa.Hak[(Ndfa.Hak$Sample=="Koa"),]

AK.Koa.df<-Ndfa.AK[(Ndfa.AK$Sample=="Koa"),]
RK.Koa.df<-Ndfa.RK[(Ndfa.RK$Sample=="Koa"),]

##### Beta -1 plot
Beta.neg1<- -1
Beta.neg2<- -2


#####################
# Beta negative 1
# AK koa Ndfa
All.Koa.betaneg1<- All.Koa %>%
  mutate(nfix.min = (Rub.min - d15N)/(Rub.min-Beta.neg1)*100) %>%
  mutate(nfix.max = (Rub.max - d15N)/(Rub.max-Beta.neg1)*100)  %>%
  mutate(nfix.med = (Rub.med - d15N)/(Rub.med-Beta.neg1)*100)

##### Site specific
# Beta negative 1
# AK koa Ndfa
AK.Koa.df.betneg1<- AK.Koa.df %>%
  mutate(nfix.AK.min = (Rub.min - d15N)/(Rub.min-Beta.neg1)*100) %>%
  mutate(nfix.AK.max = (Rub.max - d15N)/(Rub.max-Beta.neg1)*100)  %>%
  mutate(nfix.AK.med = (Rub.med - d15N)/(Rub.med-Beta.neg1)*100)

# RK koa Ndfa
RK.Koa.df.betneg1<- RK.Koa.df %>%
  mutate(nfix.RK.min = (Rub.min - d15N)/(Rub.min-Beta.neg1)*100) %>%
  mutate(nfix.RK.max = (Rub.max - d15N)/(Rub.max-Beta.neg1)*100)  %>%
  mutate(nfix.RK.med = (Rub.med - d15N)/(Rub.med-Beta.neg1)*100)


## Max
par(mfrow=c(1,2), mar=c(5,5,3,3))

# build empty plot
plot(data=All.Koa.betaneg1, d15N~nfix.max, yaxt="n", xaxt="n", ylim=c(-2,3.5), xlim=c(100, -30), 
     xlab="", ylab="", type="n")

# add shaded areas
# max and median are highest and lowest respectively

# models Max
B1.mod.Koa.max<-lm(d15N~nfix.max, data=All.Koa.betaneg1) 

# models Median
B1.mod.Koa.med<-lm(d15N~nfix.med, data=All.Koa.betaneg1)

par(new=T)

#for convex hull
x <- seq(-40,100, 1) # sequence
ymax.beta1 <- x*(B1.mod.Koa.max$coefficients[2])+B1.mod.Koa.max$coefficients[1] # x*slope + intercept
ymed.beta1 <- x*(B1.mod.Koa.med$coefficients[2])+B1.mod.Koa.med$coefficients[1]
polygon(c(rev(x), x),c(rev(ymax.beta1), ymed.beta1),col=adjustcolor("palegreen3",alpha.f=0.2), border=NA)

# add model lines
abline(B1.mod.Koa.max, col="black", lty=1)

# plot points and model fits
par(new=T)

# AK 
plot(data=AK.Koa.df.betneg1, d15N~nfix.AK.max, col="coral",
     xlab=expression(paste("Ndfa-", italic("Acacia koa"), " (%)", sep="")),
     ylab= expression(paste(italic("Acacia koa "),delta^{15}, N, " (\u2030)")), cex.axis=0.7, 
     main= "Beta = -1", cex.main=0.7,
     ylim=c(-2,3.5), xlim=c(100, -30), cex=0.7, pch=20)

#RK
par(new=T)
plot(data=RK.Koa.df.betneg1, d15N~nfix.RK.max, col="dodgerblue", xlab="", ylab= "", xaxt="n", yaxt="n", bty="n",
     ylim=c(-2,3.5), xlim=c(100, -30), cex=0.7, pch=20)
legend(x=135, y=3.7, x.intersp =0.15, cex=0.8, legend= c("AK", "RK","means"), bg="transparent", 
       col=c("coral", "dodgerblue", "black"), 
       pch=c(20, 20, 21), box.lty=0)


## Median
# AK 
par(new=T)
# add model lines
abline(B1.mod.Koa.med, col="black", lty=2)

par(new=T)
plot(data=AK.Koa.df.betneg1, d15N~nfix.AK.med, col="coral", xlab="", ylab= "", xaxt="n", yaxt="n", bty="n",
     ylim=c(-2,3.5), xlim=c(100, -30), cex=0.7, pch=20)

#RK
par(new=T)
plot(data=RK.Koa.df.betneg1, d15N~nfix.RK.med, col="dodgerblue", xlab="", ylab= "", xaxt="n", yaxt="n", bty="n",
     ylim=c(-2,3.5), xlim=c(100, -30), cex=0.7, pch=20)
legend(x=95, y=-1, x.intersp =0.25, legend= c("max", "median"), bg="transparent",
       col="black", lty=c(1,2), seg.len=0.4, cex=0.7, box.lty=0, pch=21)


# means, FOR max
AK.max.mean.nfixB1<-mean(AK.Koa.df.betneg1$nfix.AK.max) # mean 58.6
RK.max.mean.nfixB1<-mean(RK.Koa.df.betneg1$nfix.RK.max) # mean 43.0

# means, FOR median
AK.med.mean.nfixB1<-mean(AK.Koa.df.betneg1$nfix.AK.med) # mean 36.3
RK.med.mean.nfixB1<-mean(RK.Koa.df.betneg1$nfix.RK.med) # mean 12.3

# y d15N means
AK.mean.d15NB1<-mean(AK.Koa.df.betneg1$d15N) # mean 1.28
RK.mean.d15NB1<-mean(RK.Koa.df.betneg1$d15N) # mean 2.15

######
# add to plot (max)
points(x=AK.max.mean.nfixB1, y=AK.mean.d15NB1, pch=1, col="firebrick3", cex=1.2) # AK means
points(x=RK.max.mean.nfixB1, y=RK.mean.d15NB1, pch=1, col="blue", cex=1.2) # RK means

# add to plot (median)
points(x=AK.med.mean.nfixB1, y=AK.mean.d15NB1, pch=1, col="firebrick3", cex=1.2) # AK means
points(x=RK.med.mean.nfixB1, y=RK.mean.d15NB1, pch=1, col="blue", cex=1.2) # RK means



###################
###################
# Beta negative 2

##### Beta -2 plot
# Beta negative 2
# AK koa Ndfa
# Beta negative 1
# AK koa Ndfa
All.Koa.betaneg2<- All.Koa %>%
  mutate(nfix.min = (Rub.min - d15N)/(Rub.min-Beta.neg2)*100) %>%
  mutate(nfix.max = (Rub.max - d15N)/(Rub.max-Beta.neg2)*100)  %>%
  mutate(nfix.med = (Rub.med - d15N)/(Rub.med-Beta.neg2)*100)

##### Site specific
# Beta negative 1
# AK koa Ndfa
AK.Koa.df.betneg2<- AK.Koa.df %>%
  mutate(nfix.AK.min = (Rub.min - d15N)/(Rub.min-Beta.neg2)*100) %>%
  mutate(nfix.AK.max = (Rub.max - d15N)/(Rub.max-Beta.neg2)*100)  %>%
  mutate(nfix.AK.med = (Rub.med - d15N)/(Rub.med-Beta.neg2)*100)

# RK koa Ndfa
RK.Koa.df.betneg2<- RK.Koa.df %>%
  mutate(nfix.RK.min = (Rub.min - d15N)/(Rub.min-Beta.neg2)*100) %>%
  mutate(nfix.RK.max = (Rub.max - d15N)/(Rub.max-Beta.neg2)*100)  %>%
  mutate(nfix.RK.med = (Rub.med - d15N)/(Rub.med-Beta.neg2)*100)


## Max
# build empty plot
plot(data=All.Koa.betaneg2, d15N~nfix.max, yaxt="n", xaxt="n", ylim=c(-2,3.5), xlim=c(100, -30), 
     xlab="", ylab="", type="n")

# add shaded areas
# max and median are highest and lowest respectively

# models Max
B2.mod.Koa.max<-lm(d15N~nfix.max, data=All.Koa.betaneg2) 

# models Median
B2.mod.Koa.med<-lm(d15N~nfix.med, data=All.Koa.betaneg2)

par(new=T)

#for convex hull
x <- seq(-40,100, 1) # sequence
ymax.beta1 <- x*(B2.mod.Koa.max$coefficients[2])+B2.mod.Koa.max$coefficients[1] # x*slope + intercept
ymed.beta1 <- x*(B2.mod.Koa.med$coefficients[2])+B2.mod.Koa.med$coefficients[1]
polygon(c(rev(x), x),c(rev(ymax.beta1), ymed.beta1),col=adjustcolor("palegreen3",alpha.f=0.2), border=NA)

# add model lines
abline(B2.mod.Koa.max, col="black", lty=1)

# plot points and model fits
par(new=T)

# AK 
plot(data=AK.Koa.df.betneg2, d15N~nfix.AK.max, col="coral", yaxt="n" ,
     xlab=expression(paste("Ndfa-", italic("Acacia koa"), " (%)", sep="")),
     ylab= "", cex.axis=0.7, 
     main= "Beta = -2", cex.main=0.7,
     ylim=c(-2,3.5), xlim=c(100, -30), cex=0.7, pch=20)
axis(side=2, labels=F)

#RK
par(new=T)
plot(data=RK.Koa.df.betneg2, d15N~nfix.RK.max, col="dodgerblue", xlab="", ylab= "", xaxt="n", yaxt="n", bty="n",
     ylim=c(-2,3.5), xlim=c(100, -30), cex=0.7, pch=20)


## Median
# AK 
par(new=T)
# add model lines
abline(B2.mod.Koa.med, col="black", lty=2)

par(new=T)
plot(data=AK.Koa.df.betneg2, d15N~nfix.AK.med, col="coral", xlab="", ylab= "", xaxt="n", yaxt="n", bty="n",
     ylim=c(-2,3.5), xlim=c(100, -30), cex=0.7, pch=20)

#RK
par(new=T)
plot(data=RK.Koa.df.betneg2, d15N~nfix.RK.med, col="dodgerblue", xlab="", ylab= "", xaxt="n", yaxt="n", bty="n",
     ylim=c(-2,3.5), xlim=c(100, -30), cex=0.7, pch=20)


# means, FOR max
AK.max.mean.nfixB2<-mean(AK.Koa.df.betneg2$nfix.AK.max) # mean 58.6
RK.max.mean.nfixB2<-mean(RK.Koa.df.betneg2$nfix.RK.max) # mean 43.0

# means, FOR median
AK.med.mean.nfixB2<-mean(AK.Koa.df.betneg2$nfix.AK.med) # mean 36.3
RK.med.mean.nfixB2<-mean(RK.Koa.df.betneg2$nfix.RK.med) # mean 12.3

# y d15N means
AK.mean.d15NB2<-mean(AK.Koa.df.betneg2$d15N) # mean 1.28
RK.mean.d15NB2<-mean(RK.Koa.df.betneg2$d15N) # mean 2.15

######
# add to plot (max)
points(x=AK.max.mean.nfixB2, y=AK.mean.d15NB2, pch=1, col="firebrick3", cex=1.2) # AK means
points(x=RK.max.mean.nfixB2, y=RK.mean.d15NB2, pch=1, col="blue", cex=1.2) # RK means

# add to plot (median)
points(x=AK.med.mean.nfixB2, y=AK.mean.d15NB2, pch=1, col="firebrick3", cex=1.2) # AK means
points(x=RK.med.mean.nfixB2, y=RK.mean.d15NB2, pch=1, col="blue", cex=1.2) # RK means


dev.copy(pdf, "figures/Ndfa.update.pdf", width=7, height=5, encod="MacRoman")
dev.off()

```

```{r Ndfa with site different refs, eval=FALSE}
# Beta negative 1
# AK koa Ndfa
AK.Koa.df.betneg1<- AK.Koa.df %>%
  mutate(nfix.AK.min = (AK.R.min - d15N)/(AK.R.min-Beta.neg1)*100) %>%
  mutate(nfix.AK.max = (AK.R.max - d15N)/(AK.R.max-Beta.neg1)*100)  %>%
  mutate(nfix.AK.med = (AK.R.med - d15N)/(AK.R.med-Beta.neg1)*100) %>%
  mutate(nfix.AK.av = (Rub.av - d15N)/(Rub.av-Beta.neg1)*100) %>%
  mutate(nfix.AK.all.med = (Rub.med - d15N)/(Rub.med-Beta.neg1)*100)

# RK koa Ndfa
RK.Koa.df.betneg1<- RK.Koa.df %>%
  mutate(nfix.RK.min = (RK.R.min - d15N)/(RK.R.min-Beta.neg1)*100) %>%
  mutate(nfix.RK.max = (RK.R.max - d15N)/(RK.R.max-Beta.neg1)*100)  %>%
  mutate(nfix.RK.med = (RK.R.med - d15N)/(RK.R.med-Beta.neg1)*100) %>%
  mutate(nfix.RK.av = (Rub.av - d15N)/(Rub.av-Beta.neg1)*100) %>%
  mutate(nfix.RK.all.med = (Rub.med - d15N)/(Rub.med-Beta.neg1)*100)

All.Koa.neg1<- All.Koa %>%
  mutate(nfix.allKoa.med = (Rub.med - d15N)/(Rub.med-Beta.neg1)*100)


## Max
par(mfrow=c(1,2), mar=c(5,5,3,3))

# build empty plot
plot(data=AK.Koa.df.betneg1, d15N~nfix.AK.max, yaxt="n", xaxt="n", ylim=c(-2,3.5), xlim=c(100, -30), 
     xlab="", ylab="", type="n")

# add shaded areas
# max and median are highest and lowest respectively

# models Max (highest)
B1.mod.AKoa.max<-lm(d15N~nfix.AK.max, data=AK.Koa.df.betneg1) 
B1.mod.RKoa.max<-lm(d15N~nfix.RK.max, data=RK.Koa.df.betneg1)

# models Median (lowest)
B1.mod.AKoa.med<-lm(d15N~nfix.AK.med, data=AK.Koa.df.betneg1)
B1.mod.RKoa.med<-lm(d15N~nfix.RK.med, data=RK.Koa.df.betneg1)

par(new=T)

#for AK
x <- seq(-40,100, 1) # sequence
ymax.AK <- x*(B1.mod.AKoa.max$coefficients[2])+B1.mod.AKoa.max$coefficients[1] # x*slope + intercept
ymed.AK <- x*(B1.mod.AKoa.med$coefficients[2])+B1.mod.AKoa.med$coefficients[1]
polygon(c(rev(x), x),c(rev(ymax.AK), ymed.AK),col=adjustcolor("coral",alpha.f=0.2), border=NA)

#for RK
ymax.RK <- x*(B1.mod.RKoa.max$coefficients[2])+B1.mod.RKoa.max$coefficients[1] # x*slope + intercept
ymed.RK <- x*(B1.mod.RKoa.med$coefficients[2])+B1.mod.RKoa.med$coefficients[1]
polygon(c(rev(x), x),c(rev(ymax.RK), ymed.RK),col=adjustcolor("dodgerblue",alpha.f=0.2), border=NA)

# plot points and model fits
par(new=T)

# AK 
plot(data=AK.Koa.df.betneg1, d15N~nfix.AK.max, col="coral",
     xlab=expression(paste("Ndfa-", italic("Acacia koa"), " (%)", sep="")),
     ylab= expression(paste(delta^{15}, N, " (\u2030)")), cex.axis=0.7, main= "Beta = -1", cex.main=0.7,
     ylim=c(-2,3.5), xlim=c(100, -30), cex=0.7, pch=20)

#RK
par(new=T)
plot(data=RK.Koa.df.betneg1, d15N~nfix.RK.max, col="dodgerblue", xlab="", ylab= "", xaxt="n", yaxt="n", bty="n",
     ylim=c(-2,3.5), xlim=c(100, -30), cex=0.7, pch=20)
legend(x=135, y=3.7, x.intersp =0.15, cex=0.8, legend= c("AK", "RK"), bg="transparent", 
       col=c("coral", "dodgerblue"), 
       pch=20, box.lty=0)

# add model lines
abline(B1.mod.AKoa.max, col="coral", lty=1)
abline(B1.mod.RKoa.max, col="royalblue3", lty=1)

## Median
# AK 
par(new=T)
plot(data=AK.Koa.df.betneg1, d15N~nfix.AK.med, col="coral", xlab="", ylab= "", xaxt="n", yaxt="n", bty="n",
     ylim=c(-2,3.5), xlim=c(100, -30), cex=0.7, pch=20)

#RK
par(new=T)
plot(data=RK.Koa.df.betneg1, d15N~nfix.RK.med, col="dodgerblue", xlab="", ylab= "", xaxt="n", yaxt="n", bty="n",
     ylim=c(-2,3.5), xlim=c(100, -30), cex=0.7, pch=20)
legend(x=95, y=-1, x.intersp =0.25, legend= c("max", "site median", "pooled  median"), bg="transparent",
       col="black", lty=c(1,4,5), seg.len=0.4, cex=0.7, box.lty=0, pch=c(16,16,1))

# model
B1.mod.AKoa.med<-lm(d15N~nfix.AK.med, data=AK.Koa.df.betneg1)
B1.mod.RKoa.med<-lm(d15N~nfix.RK.med, data=RK.Koa.df.betneg1)

# add model lines
abline(B1.mod.AKoa.med, col="coral", lty=4)
abline(B1.mod.RKoa.med, col="royalblue3", lty=4)


###
#### all sample median
B1.mod.allKoa.med<-lm(d15N~nfix.allKoa.med, data=All.Koa.neg1)
# add model lines
abline(B1.mod.allKoa.med, col="gray40", lty=5)

par(new=T)
#AK
plot(data=AK.Koa.df.betneg1, d15N~nfix.AK.all.med, col="coral", xlab="", ylab= "", xaxt="n", yaxt="n", bty="n",
     ylim=c(-2,3.5), xlim=c(100, -30), cex=0.7, pch=21, bg="white")

par(new=T)
#RK
plot(data=RK.Koa.df.betneg1, d15N~nfix.RK.all.med, col="dodgerblue", xlab="", ylab= "", 
     bty="n", xaxt="n", yaxt="n", 
     ylim=c(-2,3.5), xlim=c(100, -30), cex=0.7, pch=21, bg="white")

# means, add to plot
AK.mean.nfix<-mean(AK.Koa.df.betneg1$nfix.AK.all.med) # mean 36.3
AK.mean.d15N<-mean(AK.Koa.df.betneg1$d15N) # mean 1.28
RK.mean.nfix<-mean(RK.Koa.df.betneg1$nfix.RK.all.med) # mean 12.3
RK.mean.d15N<-mean(RK.Koa.df.betneg1$d15N) # mean 2.15

points(x=AK.mean.nfix, y=AK.mean.d15N, pch=3, col="firebrick3", lwd=1.5, cex=0.9) # AK means
points(x=RK.mean.nfix, y=RK.mean.d15N, pch=3, col="blue", lwd=1.5, cex=0.9) # RK means



###################
###################
# Beta negative 2

##### Beta -2 plot
# Beta negative 2
# AK koa Ndfa

AK.Koa.df.betneg2<- AK.Koa.df %>%
  mutate(nfix.AK.min = (AK.R.min - d15N)/(AK.R.min-Beta.neg2)*100) %>%
  mutate(nfix.AK.max = (AK.R.max - d15N)/(AK.R.max-Beta.neg2)*100)  %>%
  mutate(nfix.AK.med = (AK.R.med - d15N)/(AK.R.med-Beta.neg2)*100) %>%
  mutate(nfix.AK.av = (Rub.av - d15N)/(Rub.av-Beta.neg2)*100) %>%
  mutate(nfix.AK.all.med = (Rub.med - d15N)/(Rub.med-Beta.neg2)*100)

# RK koa Ndfa
RK.Koa.df.betneg2<- RK.Koa.df %>%
  mutate(nfix.RK.min = (RK.R.min - d15N)/(RK.R.min-Beta.neg2)*100) %>%
  mutate(nfix.RK.max = (RK.R.max - d15N)/(RK.R.max-Beta.neg2)*100)  %>%
  mutate(nfix.RK.med = (RK.R.med - d15N)/(RK.R.med-Beta.neg2)*100) %>%
  mutate(nfix.RK.av = (Rub.av - d15N)/(Rub.av-Beta.neg2)*100) %>%
  mutate(nfix.RK.all.med = (Rub.med - d15N)/(Rub.med-Beta.neg2)*100)

All.Koa.neg2<- All.Koa %>%
  mutate(nfix.allKoa.med = (Rub.med - d15N)/(Rub.med-Beta.neg2)*100)

## Max

# build empty plot
plot(data=AK.Koa.df.betneg2, d15N~nfix.AK.max, yaxt="n", xaxt="n", ylim=c(-2,3.5), xlim=c(100, -30), 
     xlab="", ylab="", type="n")

# add shaded areas
# max and median are highest and lowest respectively

# models Max (highest)
B1.mod.AKoa.max<-lm(d15N~nfix.AK.max, data=AK.Koa.df.betneg2) 
B1.mod.RKoa.max<-lm(d15N~nfix.RK.max, data=RK.Koa.df.betneg2)

# models Median (lowest)
B1.mod.AKoa.med<-lm(d15N~nfix.AK.med, data=AK.Koa.df.betneg2)
B1.mod.RKoa.med<-lm(d15N~nfix.RK.med, data=RK.Koa.df.betneg2)

par(new=T)

#for AK
x <- seq(-40,100, 1) # sequence
ymax.AK <- x*(B1.mod.AKoa.max$coefficients[2])+B1.mod.AKoa.max$coefficients[1] # x*slope + intercept
ymed.AK <- x*(B1.mod.AKoa.med$coefficients[2])+B1.mod.AKoa.med$coefficients[1]
polygon(c(rev(x), x),c(rev(ymax.AK), ymed.AK),col=adjustcolor("coral",alpha.f=0.2), border=NA)

#for RK
ymax.RK <- x*(B1.mod.RKoa.max$coefficients[2])+B1.mod.RKoa.max$coefficients[1] # x*slope + intercept
ymed.RK <- x*(B1.mod.RKoa.med$coefficients[2])+B1.mod.RKoa.med$coefficients[1]
polygon(c(rev(x), x),c(rev(ymax.RK), ymed.RK),col=adjustcolor("dodgerblue",alpha.f=0.2), border=NA)

# plot points and model fits
par(new=T)

# AK 
plot(data=AK.Koa.df.betneg2, d15N~nfix.AK.max, col="coral",
    xlab=expression(paste("Ndfa-", italic("Acacia koa"), " (%)", sep="")),
    cex.axis=0.7, main= "Beta = -2", cex.main=0.7, ylab="",
     ylim=c(-2,3.5), xlim=c(100, -30), cex=0.7, pch=20)

#RK
par(new=T)
plot(data=RK.Koa.df.betneg2, d15N~nfix.RK.max, col="dodgerblue", xlab="", ylab= "", xaxt="n", yaxt="n", bty="n",
     ylim=c(-2,3.5), xlim=c(100, -30), cex=0.7, pch=20)


# add model lines
abline(B1.mod.AKoa.max, col="coral", lty=1)
abline(B1.mod.RKoa.max, col="royalblue3", lty=1)

## Median
# AK 
par(new=T)
plot(data=AK.Koa.df.betneg2, d15N~nfix.AK.med, col="coral", xlab="", ylab= "", xaxt="n", yaxt="n", bty="n",
     ylim=c(-2,3.5), xlim=c(100, -30), cex=0.7, pch=20)

#RK
par(new=T)
plot(data=RK.Koa.df.betneg2, d15N~nfix.RK.med, col="dodgerblue", xlab="", ylab= "", xaxt="n", yaxt="n", bty="n",
     ylim=c(-2,3.5), xlim=c(100, -30), cex=0.7, pch=20)


# model
B1.mod.AKoa.med<-lm(d15N~nfix.AK.med, data=AK.Koa.df.betneg2)
B1.mod.RKoa.med<-lm(d15N~nfix.RK.med, data=RK.Koa.df.betneg2)

# add model lines
abline(B1.mod.AKoa.med, col="coral", lty=4)
abline(B1.mod.RKoa.med, col="royalblue3", lty=4)


###
#### all sample median
B1.mod.allKoa.med<-lm(d15N~nfix.allKoa.med, data=All.Koa.neg2)

# add model lines
abline(B1.mod.allKoa.med, col="gray40", lty=5)

par(new=T)
#AK
plot(data=AK.Koa.df.betneg2, d15N~nfix.AK.all.med, col="coral", xlab="", ylab= "", xaxt="n", yaxt="n", bty="n",
     ylim=c(-2,3.5), xlim=c(100, -30), cex=0.7, pch=21, bg="white")

par(new=T)
#RK
plot(data=RK.Koa.df.betneg2, d15N~nfix.RK.all.med, col="dodgerblue", xlab="", ylab= "", 
     xaxt="n", yaxt="n", bty="n",
     ylim=c(-2,3.5), xlim=c(100, -30), cex=0.7, pch=21, bg="white")
legend(x=110, y=-1.5, x.intersp =0.25, legend= c("AK-mean", "RK-mean"), bg="transparent",
       col=c("firebrick3", "blue"), cex=0.6, box.lty=0, pch=3)

# means, add to plot
AK.mean.nfix<-mean(AK.Koa.df.betneg2$nfix.AK.all.med) # mean 28.4
AK.mean.d15N<-mean(AK.Koa.df.betneg2$d15N) # mean 1.28
RK.mean.nfix<-mean(RK.Koa.df.betneg2$nfix.RK.all.med) # mean 9.64
RK.mean.d15N<-mean(RK.Koa.df.betneg2$d15N) # mean 2.25

points(x=AK.mean.nfix, y=AK.mean.d15N, pch=3, col="firebrick3", lwd=1.5, cex=0.9) # AK means
points(x=RK.mean.nfix, y=RK.mean.d15N, pch=3, col="blue", lwd=1.5, cex=0.9) # RK means


dev.copy(pdf, "figures/Ndfa.pdf", width=7, height=5, encod="MacRoman")
dev.off()


```

- if comparing in linear model the % Ndfa, they are only different (higher in AK) if you use a single shared value, in this case the grouped median (i.e, pooled Rubus d15N value across the 2 sites). FYI the mean and median are essentially the same at 2.6 permil. This is the same results if using the offset Beat -1 or -2. If using the site-specifc median and maximum value the mean %Ndfa is the same for both sites. Why? Rubus is likely influenced by the Koa, therefore it is netting a + Ndfa% through Koa/s contribution to surrounding plants. However this d15N signal from Koa is not obvious in the soils of these sites.

```{r Ndfa stats, eval=FALSE}
# tests
### Beta 1
Beta1.AK<-AK.Koa.df.betneg1[,c(1:3,5,6,8)]
names(Beta1.AK)<- c("Plot", "Sample", "d15N", "fix.max", "fix.med", "allfix.med")

Beta1.RK<-RK.Koa.df.betneg1[,c(1:3,5,6,8)]
names(Beta1.RK)<- c("Plot", "Sample", "d15N", "fix.max", "fix.med", "allfix.med")

Beta1.df<-rbind(Beta1.AK, Beta1.RK)

# test differences between the 2 forest types 
anova(lm(fix.max~Plot, data=Beta1.df)) # max, NS
anova(lm(fix.med~Plot, data=Beta1.df)) # med, NS
anova(lm(allfix.med~Plot, data=Beta1.df)) # med *p=0.114

### Beta 2
Beta2.AK<-AK.Koa.df.betneg2[,c(1:3,5,6,8)]
names(Beta2.AK)<- c("Plot", "Sample", "d15N", "fix.max", "fix.med", "allfix.med")

Beta2.RK<-RK.Koa.df.betneg2[,c(1:3,5,6,8)]
names(Beta2.RK)<- c("Plot", "Sample", "d15N", "fix.max", "fix.med", "allfix.med")

Beta2.df<-rbind(Beta2.AK, Beta2.RK)

# test differences between the 2 forest types 
anova(lm(fix.max~Plot, data=Beta2.df)) # max, NS
anova(lm(fix.med~Plot, data=Beta2.df)) # med, NS
anova(lm(allfix.med~Plot, data=Beta2.df)) # med *p=0.114

```


#### DBH, Canopy  d15N models  
- plot against d15N values with model curves
- scatters with models
- d15N differ by PLOT (AK vs RK), no other effects or relationship with DBH or Canopy

```{r, d15N and DBH Canopy, eval=FALSE}
# ** No relationship between d15N and DBH or Canopy at plot level**
# ** Effects at PLOTs on d15N (lower in AK) **


######## plot of d15N and DBH, and d15N and Canopy area

# all samples
par(mfrow=c(1,2), mar=c(4,5,1,1))

#### DBH
mod.DBH<-lm(d15N~DBH.Total*Plot, data=Hak.data) # no interaction effect

mod.DBH<-lm(d15N~DBH.Total+Plot, data=Hak.data)
int<-coef(summary(mod.DBH))[1]
DBH.slope<-coef(summary(mod.DBH))["DBH.Total",1] # DBH (slope for all figures)
RK.int<-coef(summary(mod.DBH))["PlotRK",1] # RK, AK = 0


# no significant relationship to d15N but a trend for DECREASE with DBH
plot(d15N~DBH.Total, data=Hak.data,
    col=c("coral","dodgerblue")[as.factor(Plot)],
    pch=c(1,2)[as.factor(Plot)],
    ylab=expression(paste(delta^{15}, N, " (\u2030, air)")),
    xlab="DBH (cm)",
    ylim=c(0,5), xlim=c(0,60))
    ablineclip(int, DBH.slope, col="coral", lwd=2, 
               x1 = min(Hak.data$DBH.Total[Hak.data$Plot=="AK"], na.rm=T), 
               x2 = max(Hak.data$DBH.Total[Hak.data$Plot=="AK"], na.rm=T)) # AK model
    ablineclip((int+ RK.int), DBH.slope, col="dodgerblue", lwd=2, 
               x1 = min(Hak.data$DBH.Total[Hak.data$Plot=="RK"], na.rm=T), 
               x2 = max(Hak.data$DBH.Total[Hak.data$Plot=="RK"], na.rm=T)) # RK model

    
#### Canopy
mod.Can<-lm(d15N~Canopy.area*Plot, data=Hak.data) # no interaction

mod.Can<-lm(d15N~Canopy.area+Plot, data=Hak.data)
int<-coef(summary(mod.Can))[1]
Can.slope<-coef(summary(mod.Can))["Canopy.area",1] # DBH (slope for all figures)
RK.int<-coef(summary(mod.Can))["PlotRK",1] # RK, AK = 0

# no significant relationship to d15N but a trend for INCREASE with canopy area
plot(d15N~Canopy.area, data=Hak.data, yaxt="n",
     col=c("coral","dodgerblue")[as.factor(Plot)],
     pch=c(1,2)[as.factor(Plot)],
     xlab=expression(paste("Canopy (m"^2,")")),
     ylab="", 
     ylim=c(0,5), xlim=c(0,80))
     axis(side=2, labels=F)
     ablineclip(int, Can.slope, col="coral", lwd=2, 
               x1 = min(Hak.data$Canopy.area[Hak.data$Plot=="AK"], na.rm=T), 
               x2 = max(Hak.data$Canopy.area[Hak.data$Plot=="AK"], na.rm=T)) # AK model
     ablineclip((int+ RK.int), Can.slope, col="dodgerblue", lwd=2, 
               x1 = min(Hak.data$Canopy.area[Hak.data$Plot=="RK"], na.rm=T), 
               x2 = max(Hak.data$Canopy.area[Hak.data$Plot=="RK"], na.rm=T)) # RK model
     legend("topright", legend=levels(Hak.data$Plot), box.lty=0, bg="transparent", lty=1, pch=c(1,2), 
            col=c("coral", "dodgerblue"), cex=1)

dev.copy(pdf, "figures/d15N.DBH.Canopy.pdf", width=7, height=5, encod="MacRoman")
dev.off()
```
  
With Plot being most important effect, divide DBH and Canopy to be plot mean +/- SE  
*Supplemental Figure 1. with afforested and remnant forests*   
- DBH and Canopy figure as bar chart and means
- using Mann-Whitney nonparametric tests: significant plot effects
- greater DBH (AK), trend for greater Canopy (RK)  
  
```{r mean plots for DBH and Canopy, Fig.cap="Supplementary Figure 1. Mean +/- SE diameter at breast height (DBH) and *A. koa* canopy area for two afforested and remnant forest plots.", fig.align='center'}
## Models
mod.DBH<-lm(DBH.Total~Plot, data=Hak.data); anova(mod.DBH) # signif
mod.Can<-lm(Canopy.area~Plot, data=Hak.data); anova(mod.Can) # not signif, a bit wobbly in assumptions

# diagnostic plots
for(i in c(4:5)){
  Y<-Hak.data[,i]
  full<-lm(Y~Plot, data=Hak.data, na.action=na.exclude)
  R <- resid(full) #save glm residuals
  op<-par(mfrow = c(2,3), mar=c(5,4,1,2), pty="sq")
  plot(full, add.smooth = FALSE, which=1)
  QQ <- qqnorm(R, main = colnames(Hak.data)[i]) 
  QQline <- qqline(R)
  hist(R, xlab="Residuals", main = colnames(Hak.data)[i])
  plot(Hak.data$Plot, R, xlab=colnames(Hak.data)[i], ylab="Residuals")
}

# Mann-Whitney U-Test
mwu(Hak.data, DBH.Total, Plot) # signif
mwu(Hak.data, Canopy.area, Plot) # not

#### plots
DBH.m<-aggregate(DBH.Total~Plot, data=Hak.data, mean)
Can.m<-aggregate(Canopy.area~Plot, data=Hak.data, mean)

DBH.SE<-aggregate(DBH.Total~Plot, data=Hak.data, std.error)
Can.SE<-aggregate(Canopy.area~Plot, data=Hak.data, std.error)

mean.eco<-cbind(DBH.m, Can.m[2], DBH.SE[2], Can.SE[2]); colnames(mean.eco)<-c("Plot", "DBH", "Can", "D.SE", "C.SE")

pd <- position_dodge(0.7) #offset for error bars

BW.back2<-theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black", size=0.4))

### DBH plot of mean/SE by plot
DBH.plot<-ggplot(data=mean.eco, aes(x=Plot, y=DBH))+
  geom_bar(stat="identity", position = pd, width=0.7, fill="gray70")+
  geom_errorbar(aes(ymin=DBH-D.SE, ymax=DBH+D.SE), size=.5, width=0, position=pd) +
  xlab("Plots") +
  ylab("DBH (cm)") + 
  theme(legend.title = element_blank(),
        axis.text=element_text(size=6),
        axis.title=element_text(size=8))+
  annotate(geom="text", x=1.5, y=35, label=expression(paste(bold("*"))), size=4) +
  BW.back2

### Canopy plot of mean/SE by plot
Canopy.plot<-ggplot(data=mean.eco, aes(x=Plot, y=Can))+
  geom_bar(stat="identity", position = pd, width=0.7, fill="gray70")+
  geom_errorbar(aes(ymin=Can-C.SE, ymax=Can+C.SE), size=.5, width=0, position=pd) +
  xlab("Plots") +
  ylab(expression(paste("Canopy (m"^2,")"))) + 
  theme(legend.title = element_blank(),
        axis.text=element_text(size=6),
        axis.title=element_text(size=8))+
  BW.back2

#  figures together
plot_grid(DBH.plot, Canopy.plot,
     labels=c('a', 'b'), label_size=8, hjust=-1, vjust= 3, ncol=2, nrow=1)
dev.copy(pdf, "figures/Supp.Fig1.DBHCanopy.pdf", width=4, height=3.5, encod="MacRoman")
dev.off()

```
 
*Figure 2*   
data means and SE for plots  
- bar plots of d13C, d15N, TC and TN for all 4 samples types. 

```{r, plots of isotope data, Fig.cap="Supplementary Figure 2. Mean +/- SE of sample (a) d13C, (b) d15N, (c) total carbon, and (d) total nitrogen.", fig.align='center'}
## make some means and SE
d13C.m<-aggregate(d13C~Plot+Sample, data=Hak.data, mean)
d15N.m<-aggregate(d15N~Plot+Sample, data=Hak.data, mean)
TN.m<-aggregate(Total.N..mmol.gdw~Plot+Sample, data=Hak.data, mean)
TC.m<-aggregate(Total.C..mmol.gdw~Plot+Sample, data=Hak.data, mean)

d13C.SE<-aggregate(d13C~Plot+Sample, data=Hak.data, std.error)
d15N.SE<-aggregate(d15N~Plot+Sample, data=Hak.data, std.error)
TN.SE<-aggregate(Total.N..mmol.gdw~Plot+Sample, data=Hak.data, std.error)
TC.SE<-aggregate(Total.C..mmol.gdw~Plot+Sample, data=Hak.data, std.error)

d15N.n<-aggregate(d15N~Plot+Sample, data=Hak.data, length)

mean.data<- cbind(d13C.m, d15N.m[3], TN.m[3], TC.m[3], d13C.SE[3], d15N.SE[3], TN.SE[3], TC.SE[3])
colnames(mean.data)<-c("Plot", "Sample", "d13C.mean", "d15N.mean", "TN.mean", "TC.mean", "d15N.SE", "d13C.SE", "TN.SE", "TC.SE")

# rename Rubus species for plotting
levels(mean.data$Sample)[levels(mean.data$Sample)=="RUBARG"] <- "Rubus spp"
levels(mean.data$Sample)[levels(mean.data$Sample)=="RUBHAW"] <- "Rubus spp"

mean.data$Sample<-factor(mean.data$Sample, levels=c("Soil", "Koa", "Rubus spp"))

### make mean plots
pd <- position_dodge(0.7) #offset for error bars

### d13C
d13C.plot<-ggplot(data=mean.data, aes(x=Sample, y=d13C.mean, fill=Plot, group=Plot))+
  geom_bar(stat="identity", position = pd, width=0.7)+
  geom_errorbar(aes(ymin=d13C.mean-d13C.SE, ymax=d13C.mean+d13C.SE), size=.3, width=0, position=pd) +
  scale_fill_manual(values=c('lightsteelblue1', "palegreen3")) +
  xlab("Sample Type") + 
  annotate(geom="text", x=1, y=-27.5, label=expression(paste(bold("*"))), size=4) +
  annotate(geom="text", x=2, y=-33, label=expression(paste(bold("*"))), size=4) +
  annotate(geom="text", x=3, y=-33, label=expression(paste(bold("*"))), size=4) +
  theme(text = element_text(size=8)) +
  ylab(expression(paste(delta^{13}, C, " (\u2030, V-PDB)"))) + BW.back2

### d15N
d15N.plot<-ggplot(data=mean.data, aes(x=Sample, y=d15N.mean, fill=Plot, group=Plot))+
  geom_bar(stat="identity", position = pd, width=0.7)+ ylim(c(0,8)) +
  geom_errorbar(aes(ymin=d15N.mean-d15N.SE, ymax=d15N.mean+d15N.SE), size=.3, width=0, position=pd) +
  scale_fill_manual(values=c('lightsteelblue1', "palegreen3")) +
  xlab("Sample Type") + 
  theme(text = element_text(size=8)) +
  annotate(geom="text", x=2, y=2.8, label=expression(paste(bold("*"))), size=4) +
  annotate(geom="text", x=3, y=3.3, label=expression(paste(bold("*"))), size=4) +
  ylab(expression(paste(delta^{15}, N, " (\u2030, air)"))) + BW.back2

### total Carbon
TC.plot<-ggplot(data=mean.data, aes(x=Sample, y=TC.mean, fill=Plot, group=Plot))+
  geom_bar(stat="identity", position = pd, width=0.7)+ ylim(c(0, 60)) +
  geom_errorbar(aes(ymin=TC.mean-TC.SE, ymax=TC.mean+TC.SE), size=.3, width=0, position=pd) +
  scale_fill_manual(values=c('lightsteelblue1', "palegreen3")) +
  xlab("Sample Type") + 
  theme(text = element_text(size=8)) +
  annotate(geom="text", x=1, y=25, label=expression(paste(bold("*"))), size=4) +
  annotate(geom="text", x=3, y=42, label=expression(paste(bold("*"))), size=4) +
  ylab("Total Carbon (mmol/gdw)") + BW.back2

### total Nitrogen
TN.plot<-ggplot(data=mean.data, aes(x=Sample, y=TN.mean, fill=Plot, group=Plot))+
  geom_bar(stat="identity", position = pd, width=0.7)+
  geom_errorbar(aes(ymin=TN.mean-TN.SE, ymax=TN.mean+TN.SE), size=.3, width=0, position=pd) +
  scale_fill_manual(values=c('lightsteelblue1', "palegreen3")) +
  xlab("Sample Type") + 
  theme(text = element_text(size=8)) +
  ylab("Total Nitrogen (mmol/gdw)") + BW.back2

# get the legend, # create some space to the left of the legend
bar.legend <- get_legend(
  TN.plot + theme(legend.box.margin = margin(0, 0, 0, 12)) + 
    theme(legend.key.size = unit(0.3, "cm")))

#  figures together
bar.plots<-plot_grid(d13C.plot + theme(legend.position = "none"),
          d15N.plot + theme(legend.position = "none"), 
          TC.plot + theme(legend.position = "none"),
          TN.plot + theme(legend.position = "none"), nrow=1, ncol=4, labels=c('a', 'b', 'c', 'd'), 
          label_size=8, hjust=-1, vjust= 3)

plot_grid(bar.plots, bar.legend, rel_widths = c(8, 1)) # legend  1/8 size as first obj.
dev.copy(pdf, "figures/Supp.Fig2.mean.data.sample.pdf", width=7, height=3, encod="MacRoman")
dev.off()
```

Run statistics on the responses
```{r, stats on responses, results='hide', fig.show=FALSE}
#########
# models

## tests for assumptions
for(i in c(6:12)){
  Y<-Hak.data[,i]
  full<-lm(Y~Plot*Sample, data=Hak.data, na.action=na.exclude)
  R <- resid(full) #save glm residuals
 
  op<-par(mfrow = c(2,3), mar=c(5,4,1,2), pty="sq")
  plot(full, add.smooth = FALSE, which=1)
  QQ <- qqnorm(R, main = colnames(Hak.data)[i]) 
  QQline <- qqline(R)
  hist(R, xlab="Residuals", main = colnames(Hak.data)[i])
  plot(Hak.data$Plot, R, xlab=colnames(Hak.data)[i], ylab="Residuals")
  plot(Hak.data$Sample, R, xlab=colnames(Hak.data)[i], ylab="Residuals")
}

########## Separate dataframes
soil<-Hak.data[(Hak.data$Sample=="Soil"),]
Koa<-Hak.data[(Hak.data$Sample=="Koa"),]
Rubus<-Hak.data[(Hak.data$Sample=="RUBARG" | Hak.data$Sample=="RUBHAW"),]
AK.df<-Hak.data[(Hak.data$Plot=="AK"),]; AK.df.sansoil<-AK.df[!(AK.df$Sample=="Soil"),]
RK.df<-Hak.data[(Hak.data$Plot=="RK"),]; RK.df.sansoil<-RK.df[!(RK.df$Sample=="Soil"),]

######## ######## 
######## Carbon isotopes
d13C.soil<-lm(d13C~Plot, data=soil); anova(d13C.soil) # soil signif.
plot(allEffects(d13C.soil))

d13C.Koa<-lm(d13C~Plot, data=Koa); anova(d13C.Koa) # Koa signif.
plot(allEffects(d13C.Koa))

d13C.Rubus<-lm(d13C~Plot, data=Rubus); anova(d13C.Rubus) # Rubus signif.
plot(allEffects(d13C.Rubus))

d13C.AK<-lm(d13C~Sample, data=AK.df.sansoil); anova(d13C.AK) #only koa vs. rubus comparision
plot(allEffects(d13C.AK))

d13C.RK<-lm(d13C~Sample, data=RK.df.sansoil); anova(d13C.RK) #only koa vs. rubus comparision
plot(allEffects(d13C.RK))

######## Nitrogen isotopes
d15N.soil<-lm(d15N~Plot, data=soil); anova(d15N.soil) # soil signif.
plot(allEffects(d15N.soil))

d15N.Koa<-lm(d15N~Plot, data=Koa); anova(d15N.Koa) # Koa signif.
plot(allEffects(d15N.Koa))

d15N.Rubus<-lm(d15N~Plot, data=Rubus); anova(d15N.Rubus) # Rubus signif.
plot(allEffects(d15N.Rubus))

d15N.AK<-lm(d15N~Sample, data=AK.df.sansoil); anova(d15N.AK) #only koa vs. rubus comparision, signif.
plot(allEffects(d15N.AK)) 

d15N.RK<-lm(d15N~Sample, data=RK.df.sansoil); anova(d15N.RK) #only koa vs. rubus comparision, signif.
plot(allEffects(d15N.RK))




######## ######## 
######## Carbon content
TC.soil<-lm(Total.C..mmol.gdw~Plot, data=soil); anova(TC.soil) # soil signif.
plot(allEffects(TC.soil))

TC.Koa<-lm(Total.C..mmol.gdw~Plot, data=Koa); anova(TC.Koa) # Koa signif.
plot(allEffects(TC.Koa))

TC.Rubus<-lm(Total.C..mmol.gdw~Plot, data=Rubus); anova(TC.Rubus) # Rubus signif.
plot(allEffects(TC.Rubus))

C.AK<-lm(Total.C..mmol.gdw~Sample, data=AK.df.sansoil); anova(C.AK) #only koa vs. rubus comparision, signif.
plot(allEffects(C.AK)) 

C.RK<-lm(Total.C..mmol.gdw~Sample, data=RK.df.sansoil); anova(C.RK) #only koa vs. rubus comparision, signif.
plot(allEffects(C.RK))

######## ######## 
######## Nitrogen content
TN.soil<-lm(Total.N..mmol.gdw~Plot, data=soil); anova(TN.soil) # soil signif.
plot(allEffects(TN.soil))

TN.Koa<-lm(Total.N..mmol.gdw~Plot, data=Koa); anova(TN.Koa) # Koa signif.
plot(allEffects(TN.Koa))

TN.Rubus<-lm(Total.N..mmol.gdw~Plot, data=Rubus); anova(TN.Rubus) # Rubus signif.
plot(allEffects(TN.Rubus))

N.AK<-lm(Total.N..mmol.gdw~Sample, data=AK.df.sansoil); anova(N.AK) #only koa vs. rubus comparision, signif.
plot(allEffects(N.AK)) 

N.RK<-lm(Total.N..mmol.gdw~Sample, data=RK.df.sansoil); anova(N.RK) #only koa vs. rubus comparision, signif.
plot(allEffects(N.RK))



```
**d13C model**
```{r, d13C}

```
**d15N model**
```{r, d15N}

```
**Carbon content model**
```{r, C content}

```
**Nitrogen content model**
```{r, N content}

```
  
  
###ISO-KRIG
Give the data a "krig-over".  
  
First, make krigs of the full plot and all data layers
```{r}
# load data
krig<-read.csv("data/krig.matrix.csv") # matrix of points for isoscape grid

# merge kriging data with isotope data
data.merge<-as.data.frame(join_all(list(Hak.data, krig), by = "Position.point", type='full'))

data.merge<-data.merge[c(-167:-194),] # drop NAs where no samples taken
scape.data<-data.merge

write.csv(scape.data, "output/scape.data.csv")

#################
################# make site maps based on bubble plots

# just AK site
krig.AK<- scape.data %>% filter(Plot=="AK")

# modify one point slightly due to overlap of coordinate system
krig.AK$y.matrix[24]=2.4; krig.AK$y.meter[24]=2.4
krig.AK$x.matrix[24]=5.4; krig.AK$x.meter[24]=5.4

AK.map<-krig.AK %>% as.data.frame %>% 
  ggplot(aes(x.meter, y.meter, group=Sample)) + geom_point(aes(size=d15N, color=Sample), alpha=3/4) + 
  ggtitle("AK plot--d15N (permil)") + coord_equal() + theme_bw()

# just RK site
krig.RK<- scape.data %>% filter(Plot=="RK")
 
RK.map<-krig.RK %>% as.data.frame %>% 
  ggplot(aes(x.meter, y.meter, group=Sample)) + geom_point(aes(size=d15N, color=Sample), alpha=3/4) +
  ggtitle("RK plot--d15N (permil)") + coord_equal() + theme_bw()

plot_grid(RK.map, AK.map, ncol=2, nrow=1)
dev.copy(pdf, "figures/dot.scape.pdf", width=9, height=4, encod="MacRoman")
dev.off()

#####################
#####################

## Krig AK sites
coordinates(krig.AK)<- ~x.meter + y.meter

# Create a grid of "Pixels" using x as columns and y as rows
# And the rows and columns of pixels:
Columns=seq(from=-1, to=36, by=0.05)
Rows=seq(from=-1, to=21, by=0.05)
Grid.AK <- expand.grid(x=Columns,y=Rows)
coordinates(Grid.AK) <- ~ x+y
gridded(Grid.AK) <- TRUE # Plot the grid and points

## expand binding box 
krig.AK@bbox # current data binding box
x<-c(-1, 36)
y<-c(-1, 21)
xy<-cbind(x,y)
S<-SpatialPoints(xy)
bbox(S)
krig.AK@bbox<-bbox(S) # expanded binding box for data
Grid.AK@bbox<-bbox(S) # expand for plot corner

# autokrige
d15N.AK.auto <- autoKrige(d15N ~ 1, krig.AK, Grid.AK) # ordinary kriging
plot(d15N.AK.auto, sp.layout = list(pts = list("sp.points", krig.AK)))
d15N.AK.auto$krige_output

# make to dataframes for lm, combine
AK.pred <- d15N.AK.auto[1] %>% as.data.frame() # model predictions
AK.df <- krig.AK %>% as.data.frame() # dataframe

# make dataframe with data and predictions (krig) to assess fit
pred.AK.df<- left_join(AK.df, AK.pred, by = c("x.meter"="krige_output.x")) # longest axis is x
mod <- lm(krige_output.var1.pred ~ d15N, data=pred.AK.df)
summary(mod) #R squared = 0.21

mean(pred.AK.df$krige_output.var1.pred, na.rm=T) # mean of predictions 4.4 d15N
mean(pred.AK.df$krige_output.var1.stdev, na.rm=T) # 2.1

# inspect model
plot(pred.AK.df$krige_output.var1.pred ~ pred.AK.df$d15N, xlab = "Observed", ylab = "Predicted", cex=0.2)
abline(0,1, lty=2)
abline(mod, col = "blue")

# Adding the sp.layout parameter shows the locations of the measurements
my.palette <- brewer.pal(n = 9, name = "RdBu")

# map in automap
automapPlot(d15N.AK.auto$krige_output, "var1.pred", sp.layout = list("sp.points", krig.AK, pch=16, col="gray20", cex=0.5), col.regions=my.palette)

# map in ssplot
# note that the prediction "var1.pred" component of the krig is a SpatialPixelsDataFrame. Need to call the krig, then the component df("krige_output"), then the output column ("var1.pred") to plot in spplot

# variance
spplot(d15N.AK.auto$krige_output,"var1.stdev")

#predicted krige
my.palette2 <- brewer.pal(n = 6, name = "BuGn")
my.palette3 <- colorRampPalette(c("green4", "darkseagreen1", "azure1"))(4)
col.scheme.N <- colorRampPalette(my.palette3)


plotd15N.krig.AK<-spplot(d15N.AK.auto$krige_output["var1.pred"], col.regions=col.scheme.N, 
       sp.layout = list("sp.points", krig.AK, pch=16, col="black", cex=0.5, alpha=0.5),
       main=list(label=expression(paste(delta^{15}, N, " - AK (Restored Forest)")), cex=0.8))
plotd15N.krig.AK


###########################
# RK Site Krig
###########################
## Krig AK site 
krig.RK<- scape.data %>% filter(Plot=="RK")
coordinates(krig.RK)<- ~x.meter + y.meter

Columns=seq(from=-1, to=21, by=0.05)
Rows=seq(from=-1, to=36, by=0.05)
Grid.RK <- expand.grid(x=Columns,y=Rows)
coordinates(Grid.RK) <- ~ x+y
gridded(Grid.RK) <- TRUE # Plot the grid and points

## expand binding box 
krig.RK@bbox # current data binding box
x<-c(-1, 21)
y<-c(-1, 36)
xy<-cbind(x,y)
S<-SpatialPoints(xy)
bbox(S)
Grid.RK@bbox<-bbox(S) # expand for plot corner

# autokrige
d15N.RK.auto <- autoKrige(d15N ~ 1, krig.RK, Grid.RK) # ordinary kriging
plot(d15N.RK.auto, sp.layout = list(pts = list("sp.points", krig.RK)))
d15N.RK.auto$krige_output

# make to dataframes for lm, combine
RK.pred <- d15N.RK.auto[1] %>% as.data.frame() # model predictions
RK.df <- krig.RK %>% as.data.frame() # dataframe

# make dataframe with data and predictions (krig) to assess fit
# longest axis here is y
pred.RK.df<- left_join(RK.df, RK.pred, by = c("x.meter"="krige_output.x"))
mod <- lm(krige_output.var1.pred ~ d15N, data=pred.RK.df)
summary(mod) #R squared = 0.17
mean(pred.RK.df$krige_output.var1.pred, na.rm=T) # mean of predictions 5.0 d15N
mean(pred.RK.df$krige_output.var1.stdev, na.rm=T) # 1.8

# inspect model
plot(pred.RK.df$krige_output.var1.pred ~ pred.RK.df$d15N, xlab = "Observed", ylab = "Predicted", cex=0.2)
abline(0,1, lty=2)
abline(mod, col = "blue")

# map in automap
automapPlot(d15N.RK.auto$krige_output, "var1.pred", sp.layout = list("sp.points", krig.RK), col.regions=my.palette)

# variance
spplot(d15N.RK.auto$krige_output,"var1.stdev")

#predicted krige
plotd15N.krig.RK<-spplot(d15N.RK.auto$krige_output["var1.pred"], col.regions=col.scheme.N, 
       sp.layout = list("sp.points", krig.RK, pch=16, col="black", cex=0.5, alpha=0.5), 
       main=list(label=expression(paste(delta^{15}, N, " - RK (Remnant Forest)")), cex=0.7), colorkey=FALSE)
plotd15N.krig.RK


#####################
grid.draw.ggmatrix <- function(x, recording = TRUE) {
  print(x)
}
### combined Ak-Rk krig d15N plot 
par(mfrow=c(1,2))
gridExtra::grid.arrange(plotd15N.krig.RK, plotd15N.krig.AK, ncol=2, nrow=1, widths = c(1,1.2))
dev.copy(png, "figures/RKAK.d15N.krig2.png", width = 8, height = 4, units = 'in', res = 300)
dev.off()





###################
# make density plots using predictions
# combine the predictions for each plot
AK.df.out<-as.data.frame(AK.pred$krige_output.var1.pred); AK.df.out$Plot<-"AK"
RK.df.out<-as.data.frame(RK.pred$krige_output.var1.pred); RK.df.out$Plot<-"RK"; 
colnames(AK.df.out)<-c("d15N.pred", "Plot")
colnames(RK.df.out)<-c("d15N.pred", "Plot")

# new dataframe
pred.dat<-rbind(AK.df.out, RK.df.out)
pred.dat$Plot<-as.factor(pred.dat$Plot)
pred.dat %>% 
  group_by(Plot) %>%
  summarise(no_rows = length(Plot))

#man whitney for significance (not normal data)
mwu(pred.dat, d15N.pred, Plot) # signif difference in predictions (p<0.001)

# Density plot

hist(pred.dat$d15N.pred[(pred.dat$Plot=="AK")], ylim=c(0,150000), xlab="d15N-predict")
hist(pred.dat$d15N.pred[(pred.dat$Plot=="RK")], ylim=c(0,150000), xlab="d15N-predict")
# plot.means
predict.mean <- ddply(pred.dat, "Plot", summarise, grp.mean=mean(d15N.pred, na.rm=TRUE))

density.predict<-ggplot(pred.dat, aes(x=d15N.pred)) +
  geom_density(aes(color=Plot, fill=Plot), alpha=0.5)+
  xlab(expression(paste(delta^{15}, N["predicted"], sp="")))+
  scale_color_manual(values=c("#E69F00", "#56B4E9")) +
  scale_fill_manual(values=c("#E69F00", "#56B4E9")) +
  geom_vline(data=predict.mean, aes(xintercept=grp.mean, color=Plot),
             linetype="dashed", lwd=0.2) + BW.back2

print(density.predict)
dev.copy(pdf, "figures/mod.pred.pdf", width = 4, height = 4)
dev.off()


```
  
Now make rasters and kirgs for the types of data for analysis.

#### AK plot rasters  

Subset data and only examine **KOA** in the plots. 
```{r}
###### AK site

## d15N koa plot
krig.AK<- scape.data %>% filter(Plot=="AK") # just AK
krig.AK$Sample<-factor(krig.AK$Sample, levels=c("Koa", "RUBHAW", "Soil"))

KOA.AK<-  krig.AK[c(krig.AK$Sample=="Koa"),] #just Koa
coordinates(KOA.AK)<- ~x.meter + y.meter # coordinate system

# create a bubble plot with the random values
bubble(KOA.AK, zcol='d15N', fill=TRUE, do.sqrt=FALSE, maxsize=3)

TheVariogram=variogram(d15N~1, data=KOA.AK)
plot(TheVariogram)

TheVariogramModel <- vgm(psill=0.2, model="Gau", nugget=0.1, range=8)
plot(TheVariogram, model=TheVariogramModel)

FittedModel <- fit.variogram(TheVariogram, model=TheVariogramModel)

plot(TheVariogram, model=FittedModel)

# Create a "gstat" object
TheGStat <- gstat(id="Sine", formula=d15N ~ 1, data=KOA.AK)
TheVariogram=variogram(TheGStat, map=TRUE, cutoff=4000, width=200)

## the original data had a large north-south trend, check with a variogram map
plot(TheVariogram, threshold=1)

# Create directional variograms at 0, 45, 90, 135 degrees from north (y-axis)
TheVariogram <- variogram(TheGStat, alpha=c(0,45,90,135))

# Create a new model
TheModel=vgm(model='Lin' , anis=c(0,0.5))

# Fit a model to the variogram
FittedModel <- fit.variogram(TheVariogram, model=TheModel)

## plot results:
plot(TheVariogram, model=FittedModel, as.table=TRUE)

# update the gstat object:
TheGStat <- gstat(TheGStat, id="Sine", model=FittedModel )

# create sequences that represent the center of the columns of pixels
# change "by" to change the resolution of the raster
Columns=seq(from=0, to=35, by=0.05)

# And the rows of pixels:
Rows=seq(from=0, to=20, by=0.05)

# Create a grid of "Pixels" using x as columns and y as rows
Grid.KOA.AK <- expand.grid(x=Columns,y=Rows)

# Convert Thegrid to a SpatialPixel class
coordinates(Grid.KOA.AK) <- ~ x+y

gridded(Grid.KOA.AK) <- TRUE # Plot the grid and points


par(mfrow=c(1,1), mar=c(4,4,2,2))
plot(krig.AK$d15N, col=krig.AK$Sample, cex=0.8)
legend("topleft", legend=levels(krig.AK$Sample), box.lty=0, bg="transparent", pch=1, 
            col=c("black", "red", "green"), cex=1)

title("Interpolation Grid and Sample Points")

# perform ordinary kriging prediction:
TheSurface <- predict(TheGStat, model=FittedModel, newdata=Grid.KOA.AK)

# Set the margins to 2
par(mar=c(2,2,2,2))

# Add the Kriged surface
image(TheSurface, col=terrain.colors(20))

# Add contours to the surface
contour(TheSurface, add=TRUE, drawlabels=FALSE, col='brown')

# Add the points
points(KOA.AK, pch=4, cex=0.5)

# Set the title
title('Prediction')

#####################for the second plot
### ordinary kriggin, with 'autoKrige'

## d15N koa plot
krig.AK<- scape.data %>% filter(Plot=="AK") # just AK
krig.AK$Sample<-factor(krig.AK$Sample, levels=c("Koa", "RUBHAW", "Soil"))

KOA.AK<-  krig.AK %>% filter(Sample=="Koa") #just Koa
coordinates(KOA.AK)<- ~x.meter + y.meter # coordinate system

# point grid for interpolation is 'Grid.KOA.AK' (below)
Columns=seq(from=0, to=35, by=0.05)
Rows=seq(from=0, to=20, by=0.05)
Grid.KOA.AK <- expand.grid(x=Columns,y=Rows) # Create a grid of "Pixels" using x as columns and y as rows
coordinates(Grid.KOA.AK) <- ~ x+y  # Convert Thegrid to a SpatialPixel class
gridded(Grid.KOA.AK) <- TRUE # Plot the grid and points

# autokrige
d15N.KOA.AK.auto <- autoKrige(d15N ~ 1, KOA.AK, Grid.KOA.AK) # ordinary kriging
plot(d15N.KOA.AK.auto, sp.layout = list(pts = list("sp.points", KOA.AK)))
d15N.KOA.AK.auto$krige_output

# make to dataframes for lm, combine
AK.Koa.pred <- d15N.KOA.AK.auto[1] %>% as.data.frame() # model predictions
AK.Koa.df <- KOA.AK %>% as.data.frame() # dataframe

# make dataframe with data and predictions (krig) to assess fit
pred.KOA.AK<- left_join(AK.Koa.df, AK.Koa.pred, by = c("x.meter"="krige_output.x"))
mod <- lm(krige_output.var1.pred ~ d15N, data=pred.KOA.AK)
summary(mod) #R squared = 0.174

# inspect model
plot(pred.KOA.AK$krige_output.var1.pred ~ pred.KOA.AK$d15N, xlab = "Observed", ylab = "Predicted", cex=0.2)
abline(0,1, lty=2)
abline(mod, col = "blue")

# Adding the sp.layout parameter shows the locations of the measurements
my.palette <- brewer.pal(n = 9, name = "Greens")

# map in automap
automapPlot(d15N.KOA.AK.auto$krige_output, "var1.pred", sp.layout = list("sp.points", KOA.AK), col.regions=my.palette)

# map in ssplot
# note that the prediction "var1.pred" component of the krig is a SpatialPixelsDataFrame. Need to call the krig, then the component df("krige_output"), then the output column ("var1.pred") to plot in spplot

# variance
spplot(d15N.KOA.AK.auto$krige_output,"var1.pred")

#predicted krige
plotd15N.koa.krig.AK<-spplot(d15N.KOA.AK.auto$krige_output["var1.pred"], col.regions=colorRampPalette(col.scheme.N), 
       main=expression(paste(delta^{15}, N, "--AK (Afforested Koa Plot)")))
plotd15N.koa.krig.AK



### inverse distance weighted interpolationm, with 'krige'
d15N.KOA.AK <- krige(d15N ~ 1, KOA.AK, Grid.KOA.AK) # inverse distance weighted interpolation
plot(variogram(d15N ~ 1, KOA.AK)) # variogram
plot(d15N.KOA.AK)

plot(autofitVariogram(d15N ~ 1, KOA.AK))

plotd15N.koa.krig.AK<-spplot(d15N.KOA.AK[1], col.regions=colorRampPalette(col.scheme.N), 
       main=expression(paste(delta^{15}, N, "--AK (Afforested Koa Plot)")))
plotd15N.koa.krig.AK

```

Just **Rubus hawaiiensis** in AK 
```{r}
###### AK site

## d15N Rubus plot
krig.AK<- scape.data %>% filter(Plot=="AK") # just AK
krig.AK$Sample<-factor(krig.AK$Sample, levels=c("Koa", "RUBHAW", "Soil"))

RubHa.AK<-  krig.AK[c(krig.AK$Sample=="RUBHAW"),] #just Rubus Hawaiiensis
coordinates(RubHa.AK)<- ~x.meter + y.meter # coordinate system

bubble(RubHa.AK, zcol='d15N', fill=TRUE, do.sqrt=FALSE, maxsize=3)

TheVariogram=variogram(d15N~1, data=RubHa.AK)
plot(TheVariogram)

TheVariogramModel <- vgm(psill=0.6, model="Gau", nugget=0.1, range=8)
plot(TheVariogram, model=TheVariogramModel)

FittedModel <- fit.variogram(TheVariogram, model=TheVariogramModel)

plot(TheVariogram, model=FittedModel)

# Create a "gstat" object
TheGStat <- gstat(id="Sine", formula=d15N ~ 1, data=RubHa.AK)
TheVariogram=variogram(TheGStat, map=TRUE, cutoff=4000, width=200)

## the original data had a large north-south trend, check with a variogram map
plot(TheVariogram, threshold=1)

# Create directional variograms at 0, 45, 90, 135 degrees from north (y-axis)
TheVariogram <- variogram(TheGStat, alpha=c(0,45,90,135))

# Create a new model
TheModel=vgm(model='Lin' , anis=c(0,0.5))

# Fit a model to the variogram
FittedModel <- fit.variogram(TheVariogram, model=TheModel)

## plot results:
plot(TheVariogram, model=FittedModel, as.table=TRUE)

# update the gstat object:
TheGStat <- gstat(TheGStat, id="Sine", model=FittedModel )

# create sequences that represent the center of the columns of pixels
# change "by" to change the resolution of the raster
Columns=seq(from=0, to=35, by=0.1)

# And the rows of pixels:
Rows=seq(from=0, to=20, by=0.1)

# Create a grid of "Pixels" using x as columns and y as rows
Grid.RubHa.AK <- expand.grid(x=Columns,y=Rows)

# Convert Thegrid to a SpatialPixel class
coordinates(Grid.RubHa.AK) <- ~ x+y

gridded(Grid.RubHa.AK) <- TRUE # Plot the grid and points

par(mfrow=c(1,1), mar=c(4,4,2,2))
plot(krig.AK$d15N, col=krig.AK$Sample, cex=0.8)
legend("topleft", legend=levels(krig.AK$Sample), box.lty=0, bg="transparent", pch=1, 
            col=c("black", "red", "green"), cex=1)
title("RUBHa Interpolation Grid and Sample Points")

# perform ordinary kriging prediction:
TheSurface <- predict(TheGStat, model=FittedModel, newdata=Grid.RubHa.AK)

# Set the margins to 2
par(mar=c(2,2,2,2))

# Add the Kriged surface
image(TheSurface, col=terrain.colors(20))

# Add contours to the surface
contour(TheSurface, add=TRUE, drawlabels=FALSE, col='brown')

# Add the points
points(RubHa.AK, pch=4, cex=0.5)

# Set the title
title('Prediction')

##for the second plot
d15N.RubHa.AK <- autoKrige(d15N ~ 1, RubHa.AK, Grid.RubHa.AK) # ordinary kriging
plot(d15N.RubHa.AK)
plot(variogram(d15N ~ 1, RubHa.AK)) # variogram

d15N.RubHa.AK2 <- krige(d15N ~ 1, RubHa.AK, Grid.RubHa.AK) # ordinary kriging
plotd15N.RubHa.krig.AK2<-spplot(d15N.RubHa.AK2["var1.pred"], col.regions=colorRampPalette(col.scheme.N), 
       main=expression(paste(delta^{15}, N, "--AK (Afforested RubHa Plot)")))
plotd15N.RubHa.krig.AK2
```
  
Now just do **SOIL** for the AK site
```{r}
###### AK site

## d15N SOIL plot
krig.AK<- scape.data %>% filter(Plot=="AK") # just AK
krig.AK$Sample<-factor(krig.AK$Sample, levels=c("Koa", "RUBHAW", "Soil"))

Soil.AK<-  krig.AK[c(krig.AK$Sample=="Soil"),] #just Soil
coordinates(Soil.AK)<- ~x.meter + y.meter # coordinate system

bubble(Soil.AK, zcol='d15N', fill=TRUE, do.sqrt=FALSE, maxsize=3)

TheVariogram=variogram(d15N~1, data=Soil.AK)
plot(TheVariogram)

TheVariogramModel <- vgm(psill=1.5, model="Gau", nugget=1.2, range=40)
plot(TheVariogram, model=TheVariogramModel)

FittedModel <- fit.variogram(TheVariogram, model=TheVariogramModel)

plot(TheVariogram, model=FittedModel)

# Create a "gstat" object
TheGStat <- gstat(id="Sine", formula=d15N ~ 1, data=Soil.AK)
TheVariogram=variogram(TheGStat, map=TRUE, cutoff=4000, width=200)

## the original data had a large north-south trend, check with a variogram map
plot(TheVariogram, threshold=1)

# Create directional variograms at 0, 45, 90, 135 degrees from north (y-axis)
TheVariogram <- variogram(TheGStat, alpha=c(0,45,90,135))

# Create a new model
TheModel=vgm(model='Lin' , anis=c(0,0.5))

# Fit a model to the variogram
FittedModel <- fit.variogram(TheVariogram, model=TheModel)

## plot results:
plot(TheVariogram, model=FittedModel, as.table=TRUE)

# update the gstat object:
TheGStat <- gstat(TheGStat, id="Sine", model=FittedModel )

# create sequences that represent the center of the columns of pixels
# change "by" to change the resolution of the raster
Columns=seq(from=0, to=35, by=0.1)

# And the rows of pixels:
Rows=seq(from=0, to=20, by=0.1)

# Create a grid of "Pixels" using x as columns and y as rows
Grid.Soil.AK <- expand.grid(x=Columns,y=Rows)

# Convert Thegrid to a SpatialPixel class
coordinates(Grid.Soil.AK) <- ~ x+y

gridded(Grid.Soil.AK) <- TRUE # Plot the grid and points

par(mfrow=c(1,1), mar=c(4,4,2,2))
plot(krig.AK$d15N, col=krig.AK$Sample, cex=0.8)
legend("topleft", legend=levels(krig.AK$Sample), box.lty=0, bg="transparent", pch=1, 
            col=c("black", "red", "green"), cex=1)
title("SOIL Interpolation Grid and Sample Points")

# perform ordinary kriging prediction:
TheSurface <- predict(TheGStat, model=FittedModel, newdata=Grid.Soil.AK)

# Set the margins to 2
par(mar=c(2,2,2,2))

# Add the Kriged surface
image(TheSurface, col=terrain.colors(20))

# Add contours to the surface
contour(TheSurface, add=TRUE, drawlabels=FALSE, col='brown')

# Add the points
points(Soil.AK, pch=4, cex=0.5)

# Set the title
title('Prediction')

##for the second plot
d15N.Soil.AK <- autoKrige(d15N ~ 1, Soil.AK, Grid.Soil.AK) # ordinary kriging
plot(d15N.Soil.AK)
plot(variogram(d15N ~ 1, Soil.AK)) # variogram

d15N.Soil.AK2 <- krige(d15N ~ 1, Soil.AK, Grid.Soil.AK) # ordinary kriging
plotd15N.Soil.krig.AK2<-spplot(d15N.Soil.AK2["var1.pred"], col.regions=colorRampPalette(col.scheme.N), 
       main=expression(paste(delta^{15}, N, "--AK (Afforested Soil Plot)")))
plotd15N.Soil.krig.AK2
```

##### RK site rasters
  
Subset data and only examine **KOA** in the plots. 
```{r}
##############
krig.RK<- scape.data %>% filter(Plot=="RK") # just RK
krig.RK$Sample<-factor(krig.RK$Sample, levels=c("Koa", "RUBARG", "Soil"))

KOA.RK<-  krig.RK %>% filter(Sample=="Koa") #just Koa

coordinates(KOA.RK)<- ~x.meter + y.meter # coordinate system

# create a bubble plot with the random values
bubble(KOA.RK, zcol='d15N', fill=TRUE, do.sqrt=FALSE, maxsize=3)

TheVariogram=variogram(d15N~1, data=KOA.RK)
plot(TheVariogram)

TheVariogramModel <- vgm(psill=0.2, model="Gau", nugget=0.1, range=8)
plot(TheVariogram, model=TheVariogramModel)

FittedModel <- fit.variogram(TheVariogram, model=TheVariogramModel)

plot(TheVariogram, model=FittedModel)

# Create a "gstat" object
TheGStat <- gstat(id="Sine", formula=d15N ~ 1, data=KOA.RK)
TheVariogram=variogram(TheGStat, map=TRUE, cutoff=4000, width=200)

## the original data had a large north-south trend, check with a variogram map
plot(TheVariogram, threshold=1)

# Create directional variograms at 0, 45, 90, 135 degrees from north (y-axis)
TheVariogram <- variogram(TheGStat, alpha=c(0,45,90,135))

# Create a new model
TheModel=vgm(model='Lin' , anis=c(0,0.5))

# Fit a model to the variogram
FittedModel <- fit.variogram(TheVariogram, model=TheModel)

## plot results:
plot(TheVariogram, model=FittedModel, as.table=TRUE)

# update the gstat object:
TheGStat <- gstat(TheGStat, id="Sine", model=FittedModel )

Columns=seq(from=0, to=20, by=0.1)
Rows=seq(from=0, to=35, by=0.1)
Grid.KOA.RK <- expand.grid(x=Columns,y=Rows)

# Convert Thegrid to a SpatialPixel class
coordinates(Grid.KOA.RK) <- ~ x+y
gridded(Grid.KOA.RK) <- TRUE  # Plot the grid and points

par(mfrow=c(1,1), mar=c(4,4,2,2))
plot(krig.RK$d15N, col=krig.RK$Sample, cex=0.8, pch=1)
legend("topleft", legend=levels(krig.RK$Sample), box.lty=0, bg="transparent", pch=1, 
            col=c("black", "red", "green"), cex=1)
title("Interpolation Grid and Sample Points")

# perform ordinary kriging prediction:
TheSurface <- predict(TheGStat, model=FittedModel, newdata=Grid.KOA.RK)

# Set the margins to 2
par(mar=c(2,2,2,2))

# Add the Kriged surface
image(TheSurface, col=terrain.colors(20))

# Add contours to the surface
contour(TheSurface, add=TRUE, drawlabels=FALSE, col='brown')

# Add the points
points(KOA.RK, pch=4, cex=0.5)

# Set the title
title('Prediction')

##for the second plot
d15N.KOA.RK <- autoKrige(d15N ~ 1, KOA.RK, Grid.KOA.RK) # ordinary kriging
plot(d15N.KOA.RK)
plot(variogram(d15N ~ 1, KOA.RK)) # variogram

d15N.KOA.RK2 <- krige(d15N ~ 1, KOA.RK, Grid.KOA.RK) # ordinary kriging
plotd15N.koa.krig.RK<-spplot(d15N.KOA.RK2["var1.pred"], col.regions=colorRampPalette(col.scheme.N), 
       main=expression(paste(delta^{15}, N, "--RK (Remnant Koa Plot)")))
plotd15N.koa.krig.RK

```


Just **Rubus argutus** in RK 
```{r}
###### RK site

## d15N Rubus plot
krig.RK<- scape.data %>% filter(Plot=="RK") # just RK
krig.RK$Sample<-factor(krig.RK$Sample, levels=c("Koa", "RUBARG", "Soil"))

RubAr.RK<-  krig.RK[c(krig.RK$Sample=="RUBARG"),] #just Rubus argutus
coordinates(RubAr.RK)<- ~x.meter + y.meter # coordinate system

# create a bubble plot with the random values
bubble(RubAr.RK, zcol='d15N', fill=TRUE, do.sqrt=FALSE, maxsize=3)

TheVariogram=variogram(d15N~1, data=RubAr.RK)
plot(TheVariogram)

TheVariogramModel <- vgm(psill=0.2, model="Gau", nugget=0.1, range=8)
plot(TheVariogram, model=TheVariogramModel)

FittedModel <- fit.variogram(TheVariogram, model=TheVariogramModel)

plot(TheVariogram, model=FittedModel)

# Create a "gstat" object
TheGStat <- gstat(id="Sine", formula=d15N ~ 1, data=RubAr.RK)
TheVariogram=variogram(TheGStat, map=TRUE, cutoff=4000, width=200)

## the original data had a large north-south trend, check with a variogram map
plot(TheVariogram, threshold=1)

# Create directional variograms at 0, 45, 90, 135 degrees from north (y-axis)
TheVariogram <- variogram(TheGStat, alpha=c(0,45,90,135))

# Create a new model
TheModel=vgm(model='Lin' , anis=c(0,0.5))

# Fit a model to the variogram
FittedModel <- fit.variogram(TheVariogram, model=TheModel)

## plot results:
plot(TheVariogram, model=FittedModel, as.table=TRUE)

# update the gstat object:
TheGStat <- gstat(TheGStat, id="Sine", model=FittedModel )

# create sequences that represent the center of the columns of pixels
# change "by" to change the resolution of the raster
Columns=seq(from=0, to=20, by=0.1)

# And the rows of pixels:
Rows=seq(from=0, to=35, by=0.1)

# Create a grid of "Pixels" using x as columns and y as rows
Grid.RubAr.RK <- expand.grid(x=Columns,y=Rows)

# Convert Thegrid to a SpatialPixel class
coordinates(Grid.RubAr.RK) <- ~ x+y

gridded(Grid.RubAr.RK) <- TRUE # Plot the grid and points

par(mfrow=c(1,1), mar=c(4,4,2,2))
plot(krig.RK$d15N, col=krig.RK$Sample, cex=0.8)
legend("topleft", legend=levels(krig.RK$Sample), box.lty=0, bg="transparent", pch=1, 
            col=c("black", "red", "green"), cex=1)
title("RUBAr Interpolation Grid and Sample Points")

# perform ordinary kriging prediction:
TheSurface <- predict(TheGStat, model=FittedModel, newdata=Grid.RubAr.RK)

# Set the margins to 2
par(mar=c(2,2,2,2))

# Add the Kriged surface
image(TheSurface, col=terrain.colors(20))

# Add contours to the surface
contour(TheSurface, add=TRUE, drawlabels=FALSE, col='brown')

# Add the points
points(RubAr.RK, pch=4, cex=0.5)

# Set the title
title('Prediction')

##for the second plot
d15N.RubAr.RK <- autoKrige(d15N ~ 1, RubAr.RK, Grid.RubAr.RK) # ordinary kriging
plot(d15N.RubAr.RK)
plot(variogram(d15N ~ 1, RubAr.RK)) # variogram

d15N.RubAr.RK2 <- krige(d15N ~ 1, RubAr.RK, Grid.RubAr.RK) # ordinary kriging
plotd15N.RubAr.krig.RK2<-spplot(d15N.RubAr.RK2["var1.pred"], col.regions=colorRampPalette(col.scheme.N), 
       main=expression(paste(delta^{15}, N, "--RK (Remnant RubAr Plot)")))
plotd15N.RubAr.krig.RK2
```

  
Now just do **SOIL** for the RK site
```{r}
###### RK site

## d15N SOIL plot
krig.RK<- scape.data %>% filter(Plot=="RK") # just RK
krig.RK$Sample<-factor(krig.RK$Sample, levels=c("Koa", "RUBARG", "Soil"))

Soil.RK<-  krig.RK[c(krig.RK$Sample=="Soil"),] #just Soil
coordinates(Soil.RK)<- ~x.meter + y.meter # coordinate system

bubble(Soil.RK, zcol='d15N', fill=TRUE, do.sqrt=FALSE, maxsize=3)

TheVariogram=variogram(d15N~1, data=Soil.RK)
plot(TheVariogram)

TheVariogramModel <- vgm(psill=0.95, model="Gau", nugget=0, range=4.6)
plot(TheVariogram, model=TheVariogramModel)

FittedModel <- fit.variogram(TheVariogram, model=TheVariogramModel)

plot(TheVariogram, model=FittedModel)

# Create a "gstat" object
TheGStat <- gstat(id="Sine", formula=d15N ~ 1, data=Soil.RK)
TheVariogram=variogram(TheGStat, map=TRUE, cutoff=4000, width=200)

## the original data had a large north-south trend, check with a variogram map
plot(TheVariogram, threshold=1)

# Create directional variograms at 0, 45, 90, 135 degrees from north (y-axis)
TheVariogram <- variogram(TheGStat, alpha=c(0,45,90,135))

# Create a new model
TheModel=vgm(model='Lin' , anis=c(0,0.5))

# Fit a model to the variogram
FittedModel <- fit.variogram(TheVariogram, model=TheModel)

## plot results:
plot(TheVariogram, model=FittedModel, as.table=TRUE)

# update the gstat object:
TheGStat <- gstat(TheGStat, id="Sine", model=FittedModel )

# create sequences that represent the center of the columns of pixels
# change "by" to change the resolution of the raster
Columns=seq(from=0, to=20, by=0.1)

# And the rows of pixels:
Rows=seq(from=0, to=35, by=0.1)

# Create a grid of "Pixels" using x as columns and y as rows
Grid.Soil.RK <- expand.grid(x=Columns,y=Rows)

# Convert Thegrid to a SpatialPixel class
coordinates(Grid.Soil.RK) <- ~ x+y

gridded(Grid.Soil.RK) <- TRUE # Plot the grid and points


plot(krig.RK$d15N, col=krig.RK$Sample, cex=0.8)
legend("topleft", legend=levels(krig.RK$Sample), box.lty=0, bg="transparent", pch=1, 
            col=c("black", "red", "green"), cex=1)
title("Interpolation Grid and Sample Points")

# perform ordinary kriging prediction:
TheSurface <- predict(TheGStat, model=FittedModel, newdata=Grid.Soil.RK)

# Set the margins to 2
par(mar=c(2,2,2,2))

# Add the Kriged surface
image(TheSurface, col=terrain.colors(20))

# Add contours to the surface
contour(TheSurface, add=TRUE, drawlabels=FALSE, col='brown')

# Add the points
points(Soil.RK, pch=4, cex=0.5)

# Set the title
title('Prediction')

##for the second plot
d15N.Soil.RK <- autoKrige(d15N ~ 1, Soil.RK, Grid.Soil.RK) # ordinary kriging
plot(d15N.Soil.RK)
plot(variogram(d15N ~ 1, Soil.RK)) # variogram

d15N.Soil.RK2 <- krige(d15N ~ 1, Soil.RK, Grid.Soil.RK) # ordinary kriging
plotd15N.Soil.krig.RK2<-spplot(d15N.Soil.RK2["var1.pred"], col.regions=colorRampPalette(col.scheme.N), 
       main=expression(paste(delta^{15}, N, "--RK (Afforested Soil Plot)")))
plotd15N.Soil.krig.RK2 
```



```{r, eval=FALSE}
#####################
# Carbon kriging, leave alone for now.
#####################

## Krig AK site d13C
coordinates(krig.AK)<- ~x.meter + y.meter
col.scheme.C <- colorRampPalette(c('coral', 'cadetblue2', 'gray5'))(5)

Grid.AK <- spsample(krig.AK, type='regular', n=1e5)
gridded(Grid.AK) <- TRUE

## d13C plot
d13C.krig.AK <- krige(d13C ~ 1, krig.AK, Grid.AK)
plotd13C.krig.AK<-spplot(d13C.krig.AK["var1.pred"], col.regions=colorRampPalette(col.scheme.C), 
       main=expression(paste(delta^{13}, C, "--AK (Afforested Koa Plot)")))

## Krig RK site d13C
coordinates(krig.RK)<- ~x.meter + y.meter
GridRK <- spsample(krig.RK, type='regular', n=1e5)
gridded(GridRK) <- TRUE

## d13C plot
d13C.krig.RK <- krige(d13C ~ 1, krig.RK, GridRK)
plotd13C.krig.RK<-spplot(d13C.krig.RK["var1.pred"], col.regions=colorRampPalette(col.scheme.C), 
       main=expression(paste(delta^{13}, C, "--RK (Remnant Koa Plot)")))


```







```{r, kriging test, include=FALSE, eval=FALSE}
### Testing Kriging
################################################

# load data
krig<-read.csv("data/kriging.test.csv")

# simulate data
krig <- krig %>% 
  mutate(d15N.ex = as.numeric(rnorm(n=166, mean=2, sd=3)))

# just AK site
krig.AK<- krig %>% filter(site=="AK")

# example map with 
krig.AK %>% as.data.frame %>% 
  ggplot(aes(x.meter, y.meter)) + geom_point(aes(size=d15N.ex), color="forestgreen", alpha=3/4) + 
  ggtitle("d15N simulated (permil)") + coord_equal() + theme_bw()


# convert to spatial data, now a SPDF class object with 5 data slots
coordinates(krig.AK)<- ~x.meter + y.meter
str(krig.AK)
# data: contains all the variables associated with different spatial locations
# coords slot:  a matrix of all spatial locations with corresponding values
# bbox:  the bounding box or the 4 corners denoting spatial extent
# proj4string: projection inform. ie., what are the coordinates in?

# can coerce back to dataframe for plotting etc
# krig.AK<-krig.AK %>% as.data.frame %>% glimpse


##### VARIOGRAM, must be the SPDF object
# variogram function can take two arguments: 
# first: how one or more variables interact spatially
# second: SPDF object where those variables reside.


# no trend variogram
# example: variogram(log(zinc)~1, meuse)
vario.notrend <- variogram(d15N.ex~1, krig.AK)

# residual variogram w.r.t. a linear trend:
# example variogram(log(zinc)~x+y, meuse)
vario.resid <- variogram(d15N.ex~x.meter+y.meter, krig.AK) # calculates sample variogram values

# directional variogram:
# example: variogram(log(zinc)~x+y, meuse, alpha=c(0,45,90,135))
# example: variogram(log(zinc)~1, meuse, width=90, cutoff=1300)
vario.dir1 <- variogram(d15N.ex~x.meter+y.meter, krig.AK, alpha=c(0,45,90,135))
vario.dir2 <- variogram(d15N.ex~1, krig.AK, width=90, cutoff=1300)


######### fitting the variogram 
# first: variogram testing
# second: model with parameters to be fit to sample variogram
vario.fit <- fit.variogram(vario.resid, model=vgm(1, "Sph", 900, 1)) # fit model

plot(vario.resid, vario.fit) # plot the sample values, along with the fit model


##########################
# Kriging 

# need to make a grid to match where kriging/estimation is done

grid<-makegrid(krig.AK, n=1000)
colnames(grid)<-c('x.meter', 'y.meter')
grid<-as.data.frame(grid)

#where we have measurements
plot1 <- krig.AK %>% as.data.frame %>%
  ggplot(aes(x.meter, y.meter)) + geom_point(size=1) + coord_equal() + 
  ggtitle("Points with measurements")

# where we WANT measurements
plot2 <- grid %>% as.data.frame %>%
  ggplot(aes(x.meter, y.meter)) + geom_point(size=0.5) + coord_equal() + 
  ggtitle("Points at which to estimate")

#### make the plots
grid.arrange(plot1, plot2, ncol = 2)

# Once we have the prepared all of the above, we are now ready to krige. This can be done with the gstat::krige function, which usually takes four arguments:
# The model formula.
#  An SPDF of the spatial domain that has measurements.
#  An SPDF of the spatial domain to krige over.
#  A variogram model fitted to the data.
# Note that the second and third arguments have to be SPDF’s and cannot just be dataframes.


# make coordinates for grid (as we did for test data)
coordinates(grid)<- ~ x.meter + y.meter

# fit the model for the krig object (grid) and use model fit from corresponding model data above
test.krig<-krige(d15N.ex~1, krig.AK, grid, model=vario.fit)

test.krig %>% as.data.frame %>%
  ggplot(aes(x=x.meter, y=y.meter)) + geom_tile(aes(fill=var1.pred)) + coord_equal() +
  scale_fill_gradient(low = "yellow", high="red") +
  scale_x_continuous(labels=comma) + scale_y_continuous(labels=comma) +
  theme_bw()
```


